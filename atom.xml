<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://rainyclementine.github.io</id>
    <title>Siilhouette</title>
    <updated>2019-12-16T09:11:03.628Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://rainyclementine.github.io"/>
    <link rel="self" href="https://rainyclementine.github.io/atom.xml"/>
    <subtitle>Rearrange the stars</subtitle>
    <logo>https://rainyclementine.github.io/images/avatar.png</logo>
    <icon>https://rainyclementine.github.io/favicon.ico</icon>
    <rights>All rights reserved 2019, Siilhouette</rights>
    <entry>
        <title type="html"><![CDATA[BZOJ3219 巡游 点分治 单调队列 线段树]]></title>
        <id>https://rainyclementine.github.io/post/bzoj3219-xun-you-dian-fen-zhi-dan-diao-dui-lie-xian-duan-shu</id>
        <link href="https://rainyclementine.github.io/post/bzoj3219-xun-you-dian-fen-zhi-dan-diao-dui-lie-xian-duan-shu">
        </link>
        <updated>2019-12-16T03:48:48.000Z</updated>
        <content type="html"><![CDATA[<p>给定一棵树 每条边有边权 给出<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi><mi>i</mi><mi>n</mi><mi>l</mi><mi>e</mi><mi>n</mi></mrow><annotation encoding="application/x-tex">minlen</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">e</span><span class="mord mathdefault">n</span></span></span></span> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi><mi>a</mi><mi>x</mi><mi>l</mi><mi>e</mi><mi>n</mi></mrow><annotation encoding="application/x-tex">maxlen</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">e</span><span class="mord mathdefault">n</span></span></span></span><br>
求出一条长度在<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi><mi>i</mi><mi>n</mi><mi>l</mi><mi>e</mi><mi>n</mi></mrow><annotation encoding="application/x-tex">minlen</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">e</span><span class="mord mathdefault">n</span></span></span></span> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi><mi>a</mi><mi>x</mi><mi>l</mi><mi>e</mi><mi>n</mi></mrow><annotation encoding="application/x-tex">maxlen</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">e</span><span class="mord mathdefault">n</span></span></span></span>之间的路径 对路径上的边权排序<br>
使得中位数最大 如果偶数取中间较大的那一个</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mi>o</mi><mi>l</mi><mn>1</mn><mo>:</mo></mrow><annotation encoding="application/x-tex">sol1:</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span></span></span></span>点分治+线段树<br>
因为是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mi>l</mi><mi>o</mi><msup><mi>g</mi><mn>3</mn></msup><mi>n</mi></mrow><annotation encoding="application/x-tex">nlog^{3}n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.008548em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span></span><span class="mord mathdefault">n</span></span></span></span> 在一条链的时候T了<br>
二分中位数 将所有边权<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>&gt;</mo><mo>=</mo><mi>m</mi><mi>i</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">&gt;=mid</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">&gt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">d</span></span></span></span>的边权置<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 否则<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">−</span><span class="mord">1</span></span></span></span><br>
就是求是否存在一条权值为正的路径<br>
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>[</mo><mi>i</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">f[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span></span></span></span>表示之前子树的长度为i路径的最大路径权值<br>
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>g</mi><mo>[</mo><mi>i</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">g[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span></span></span></span>表示当前子树的<br>
那么维护一棵线段树 下标表示距离 维护区间最小值<br>
每次查询<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>g</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>+</mo><mi>q</mi><mi>u</mi><mi>e</mi><mi>r</mi><mi>y</mi><mo>(</mo><mi>m</mi><mi>i</mi><mi>n</mi><mi>l</mi><mi>e</mi><mi>n</mi><mo>−</mo><mi>i</mi><mo separator="true">,</mo><mi>m</mi><mi>a</mi><mi>x</mi><mi>l</mi><mi>e</mi><mi>n</mi><mo>−</mo><mi>i</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">g[i]+query(minlen-i,maxlen-i)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="mord mathdefault">u</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">e</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">e</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">i</span><span class="mclose">)</span></span></span></span>是否为正<br>
然后用<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>g</mi><mo>[</mo><mi>i</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">g[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span></span></span></span>更新<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>[</mo><mi>i</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">f[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span></span></span></span> 更新成功就更新线段树<br>
因为多次做点分治 所以可以将分治重心处理出来<br>
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>t</mi><mi>e</mi><mi>m</mi><mi>r</mi><mi>o</mi><mi>o</mi><mi>t</mi><mo>[</mo><mi>i</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">temroot[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">t</span><span class="mord mathdefault">e</span><span class="mord mathdefault">m</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">o</span><span class="mord mathdefault">o</span><span class="mord mathdefault">t</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span></span></span></span>表示<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span>点的所有子树的重心</p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
#define getchar() (p1==p2&amp;&amp;(p2=(p1=buf)+fread(buf,1,1&lt;&lt;21,stdin),p1==p2)?EOF:*p1++)
char buf[1&lt;&lt;23],*p1=buf,*p2=buf,obuf[1&lt;&lt;23],*O=obuf;

const int N=100010;
const int inf=1000000000;
int n,minlen,maxlen,tot=1,cnt,root,sum,b,head[N],maxi[N],siz[N],dis[N],dep[N],f[N],g[N];
vector&lt;int&gt;temroot[N];
bool v[N];
struct Edge{
	int suiv,ver,edge,w;
}e[N&lt;&lt;1];

struct SegmentTree{
	int maxi;
	#define maxi(x) t[x].maxi
}t[N&lt;&lt;2];

inline int rint()
{
	int res=0,fix=1;
	char ch;
	while(!isdigit(ch=getchar()))
		fix=(ch=='-')?-1:fix;
	do res=res*10+(ch^'0');
	while(isdigit(ch=getchar()));
	return fix*res;
}

inline void lnk(int x,int y,int z)
{
	e[++tot].ver=y;
	e[tot].edge=z;
	e[tot].suiv=head[x];
	head[x]=tot;
}

inline void change(int p,int l,int r,int d,int val)
{
	if(l==r)return maxi(p)=val,void();
	int mid=l+r&gt;&gt;1;
	if(d&lt;=mid)change(p&lt;&lt;1,l,mid,d,val);
	if(d&gt;mid)change(p&lt;&lt;1|1,mid+1,r,d,val);
	maxi(p)=max(maxi(p&lt;&lt;1),maxi(p&lt;&lt;1|1));
}

inline int query(int p,int l,int r,int L,int R)
{
	if(L&lt;=l &amp;&amp; r&lt;=R)return maxi(p);
	int mid=l+r&gt;&gt;1,res=-inf;
	if(L&lt;=mid)res=max(res,query(p&lt;&lt;1,l,mid,L,R));
	if(R&gt;mid)res=max(res,query(p&lt;&lt;1|1,mid+1,r,L,R));
	return res;
}

inline void getroot(int x,int fa)
{
	siz[x]=1,maxi[x]=0;
	for(int i=head[x];i;i=e[i].suiv)
	{
		int y=e[i].ver;
		if(v[y] || y==fa)continue;
		getroot(y,x);
		siz[x]+=siz[y];
		maxi[x]=max(maxi[x],siz[y]);
	}
	maxi[x]=max(maxi[x],sum-siz[x]);
	if(maxi[x]&lt;maxi[root])root=x;
}

inline void getdis(int x,int fa,int &amp;posdep)
{
	g[dep[x]]=max(g[dep[x]],dis[x]);
	posdep=max(posdep,dep[x]);
	for(int i=head[x];i;i=e[i].suiv)
	{
		int y=e[i].ver;
		if(v[y] || fa==y)continue;
		dis[y]=dis[x]+e[i].w,dep[y]=dep[x]+1;
		getdis(y,x,posdep);
	}
}

inline void init(int x)
{
	v[x]=1;
	for(int i=head[x];i;i=e[i].suiv)
	{
		int y=e[i].ver;
		if(v[y])continue;
		sum=siz[y];
		root=0;
		getroot(y,x);
		temroot[x].push_back(root);
		init(root);
	}
}

inline void solve(int x)
{	
	if(b)return;
	v[x]=1;
	int posdep=0,maxdep=0;
	f[0]=0;change(1,0,n,0,0);
	for(int i=head[x];i;i=e[i].suiv)
	{
		int y=e[i].ver;
		if(v[y])continue;
		dis[y]=e[i].w,dep[y]=1,posdep=0;
		getdis(y,x,posdep);
		for(int i=1;i&lt;=posdep;i++)if(i&lt;=minlen)
			if(g[i]+query(1,0,n,minlen-i,maxlen-i)&gt;=0)b=1;
		for(int i=0;i&lt;=posdep;i++)
			if(g[i]&gt;f[i])change(1,0,n,i,g[i]),f[i]=g[i];
		for(int i=0;i&lt;=posdep;i++)
			g[i]=-inf;
		maxdep=max(maxdep,posdep);
		if(b)break;
	}
	for(int i=0;i&lt;=maxdep;i++)
		f[i]=g[i]=-inf,change(1,0,n,i,-inf);
	if(b)return;
	for(int i:temroot[x])
		if(!v[i])solve(i);
}

inline bool valid(int mid)
{
	memset(v,0,sizeof(v));
	memset(t,0xcfcfcfcf,sizeof(t));
	for(int i=2;i&lt;=tot;i+=2)
		e[i^1].w=e[i].w=(e[i].edge&gt;=mid?1:-1);
	for(int i=0;i&lt;=n;i++)
		f[i]=g[i]=-inf;
	b=0;
	solve(temroot[0][0]);
	return b;
}

int main()
{
	n=rint(),minlen=rint(),maxlen=rint();
	int l=inf,r=0,ans=-1;
	for(int i=1,x,y,z;i&lt;n;i++)
		x=rint(),y=rint(),z=rint(),
		lnk(x,y,z),lnk(y,x,z),l=min(l,z),r=max(r,z);
	sum=maxi[0]=n;
	root=0;
	getroot(1,0);
	temroot[0].push_back(root);
	init(root);
	memset(t,0xcfcfcfcf,sizeof(t));
	while(l&lt;=r)
	{
		int mid=l+r&gt;&gt;1;
		if(valid(mid))ans=mid,l=mid+1;
		else r=mid-1;
	}
	printf(&quot;%d\n&quot;,ans);
	return 0;
} 
</code></pre>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mi>o</mi><mi>l</mi><mn>2</mn><mo>:</mo></mrow><annotation encoding="application/x-tex">sol2:</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span></span></span></span>点分治+单调队列<br>
每次枚举<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>[</mo><mi>i</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">f[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span></span></span></span> 单调队列维护<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>g</mi><mo>[</mo><mi>i</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">g[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span></span></span></span>中的在区间里的最大值</p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;

const int N=200010;
const int inf=1000000007;
const double eps=1e-5;
int n,m,tot,sum,minlen,maxlen,head[N],root,Root;
int siz[N],maxi[N],q[N],f[N],g[N];
bool v[N],b;
vector&lt;int&gt;t[N];
struct Edge{
	int suiv,ver,edge,w;
}e[N&lt;&lt;1];

inline void lnk(int x,int y,int z)
{
	e[++tot].ver=y;
	e[tot].edge=z;
	e[tot].suiv=head[x];
	head[x]=tot;
}

inline void getroot(int x,int fa)
{
	siz[x]=maxi[x]=1;
	for(int i=head[x];i;i=e[i].suiv)
	{
		int y=e[i].ver;
		if(y==fa || v[y])continue;
		getroot(y,x);
		maxi[x]=max(maxi[x],siz[y]);
		siz[x]+=siz[y];
	}
	maxi[x]=max(maxi[x],sum-siz[x]);
	if(maxi[x]&lt;maxi[root])root=x;
}

inline void getdis(int x,int fa,int dep,int dis,int&amp; maxdep)
{
	maxdep=max(maxdep,dep);
	g[dep]=max(g[dep],dis);
	for(int i=head[x];i;i=e[i].suiv)
	{
		int y=e[i].ver;
		if(v[y] || y==fa)continue;
		getdis(y,x,dep+1,dis+e[i].w,maxdep);
	}
}

inline void build(int x)
{
	v[x]=1;
	for(int i=head[x];i;i=e[i].suiv)
	{
		int y=e[i].ver;
		if(v[y])continue;
		root=0;sum=siz[y];getroot(y,x);
		t[x].push_back(root);
		build(root);
	}
	v[x]=0;
}

inline void solve(int x)
{
	v[x]=1;int posdep=0,maxdep=0;
	if(b)return v[x]=0,void();
	for(int i=head[x];i;i=e[i].suiv)
	{
		int y=e[i].ver;
		if(v[y])continue;
		posdep=0;
		getdis(y,x,1,e[i].w,posdep);
		int l=1,r=0;
		for(int ld=maxdep,rd=1;rd&lt;=posdep;rd++)
		{
			while(l&lt;=r &amp;&amp; q[l]&gt;maxlen-rd)l++;
			while(ld&gt;=minlen-rd &amp;&amp; ld&gt;=0)
			{
				while(l&lt;=r &amp;&amp; f[q[r]]&lt;=f[ld])r--;
				q[++r]=ld;ld--;
			}
			if(l&lt;=r &amp;&amp; f[q[l]]+g[rd]&gt;=0){b=1;break;}
		}
		for(int j=1;j&lt;=posdep;j++)f[j]=max(f[j],g[j]);
		maxdep=max(maxdep,posdep);
		for(int j=1;j&lt;=posdep;j++)g[j]=-1e9;
		if(b)break;
	}
	for(int i=1;i&lt;=maxdep;i++)f[i]=-1e9;
	if(b)return v[x]=0,void();
	for(int i=0,lim=t[x].size();i&lt;lim;i++)
		{solve(t[x][i]);if(b)break;}
	v[x]=0;
}

inline bool valid(int mid)
{
	b=0;
	for(int i=1;i&lt;=tot;i++)
		e[i].w=e[i].edge&gt;=mid?1:-1;
	solve(Root);
	return b;
}

int main()
{
	scanf(&quot;%d%d%d&quot;,&amp;n,&amp;minlen,&amp;maxlen);
	for(int i=1;i&lt;=n;i++)f[i]=g[i]=-1e9;
	int l=0x3f3f3f3f,r=0,ans=-1;
	for(int i=1,x,y,z;i&lt;n;i++)
		scanf(&quot;%d%d%d&quot;,&amp;x,&amp;y,&amp;z),
		l=min(l,z),r=max(r,z),lnk(x,y,z),lnk(y,x,z);
	sum=maxi[0]=n;
	getroot(1,1);
	Root=root;
	build(root);
	while(l&lt;=r)
	{
		int mid=l+r&gt;&gt;1;
		if(valid(mid))ans=mid,l=mid+1;
		else r=mid-1;
	}
	printf(&quot;%d\n&quot;,ans);
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[第十四分块(前体) 莫队二次离线]]></title>
        <id>https://rainyclementine.github.io/post/di-shi-si-fen-kuai-qian-ti-mo-dui-er-ci-chi-xian</id>
        <link href="https://rainyclementine.github.io/post/di-shi-si-fen-kuai-qian-ti-mo-dui-er-ci-chi-xian">
        </link>
        <updated>2019-11-28T10:52:56.000Z</updated>
        <content type="html"><![CDATA[<p>给定一个数列 多次询问<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>l</mi><mo separator="true">,</mo><mi>r</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">(l,r)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mclose">)</span></span></span></span><br>
每次询问<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mi>l</mi></msub><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><msub><mi>a</mi><mi>r</mi></msub></mrow><annotation encoding="application/x-tex">a_l..a_r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">.</span><span class="mord">.</span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 中<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mi>x</mi></msub></mrow><annotation encoding="application/x-tex">a_x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mi>o</mi><mi>r</mi></mrow><annotation encoding="application/x-tex">xor</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span></span></span></span> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mi>y</mi></msub></mrow><annotation encoding="application/x-tex">a_y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.716668em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>有<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>位是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>的二元组<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">(x,y)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">)</span></span></span></span>个数</p>
<p>二次离线莫队<br>
对于贡献的计算 因为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">a_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>值域很小<br>
所以可以把所有有<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>位<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>的数字预处理出来 存在<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>v</mi><mi>a</mi><mi>l</mi><mi>i</mi><mi>d</mi><mo>[</mo><mo>]</mo></mrow><annotation encoding="application/x-tex">valid[]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">i</span><span class="mord mathdefault">d</span><span class="mopen">[</span><span class="mclose">]</span></span></span></span>中<br>
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>u</mi><mi>p</mi><mi>d</mi><mi>a</mi><mi>t</mi><mi>e</mi><mo>(</mo><mi>x</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">update(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">u</span><span class="mord mathdefault">p</span><span class="mord mathdefault">d</span><span class="mord mathdefault">a</span><span class="mord mathdefault">t</span><span class="mord mathdefault">e</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span></span> 表示加入x到集合中<br>
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>q</mi><mi>u</mi><mi>e</mi><mi>r</mi><mi>y</mi><mo>(</mo><mi>x</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">query(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="mord mathdefault">u</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span></span> 返回集合中有多少个元素和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span>异或的结果中有<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>位是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span><br>
有两种配套的<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>u</mi><mi>p</mi><mi>d</mi><mi>a</mi><mi>t</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">update</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">u</span><span class="mord mathdefault">p</span><span class="mord mathdefault">d</span><span class="mord mathdefault">a</span><span class="mord mathdefault">t</span><span class="mord mathdefault">e</span></span></span></span>和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>q</mi><mi>u</mi><mi>e</mi><mi>r</mi><mi>y</mi></mrow><annotation encoding="application/x-tex">query</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="mord mathdefault">u</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span>的写法</p>
<pre><code class="language-cpp">//1:
inline void update(int x){c[x]++;}
inline int query(int x)
{
	int res=0;
	for(int i=1;i&lt;=cnt;i++)
		res+=c[x^valid[i]];
	return res;
}
//2:
inline void update(int x)
{
	for(int i=1;i&lt;=cnt;i++)
		c[x^valid[i]]++;
}
inline int query(int x){return c[x];}
</code></pre>
<p>在插入和询问同级时 复杂度是一样的<br>
但是因为二次离线时 需要进行多次询问<br>
询问次数远远大于查询 所以要采取第二种写法</p>
<pre><code class="language-cpp">#pragma GCC optimize(&quot;Ofast&quot;)
#pragma GCC target(&quot;sse3&quot;,&quot;sse2&quot;,&quot;sse&quot;)
#pragma GCC target(&quot;avx&quot;,&quot;sse4&quot;,&quot;sse4.1&quot;,&quot;sse4.2&quot;,&quot;ssse3&quot;)
#pragma GCC target(&quot;f16c&quot;)
#pragma GCC target(&quot;fma&quot;,&quot;avx2&quot;)
#pragma GCC target(&quot;xop&quot;,&quot;fma4&quot;)
#pragma GCC optimize(&quot;inline&quot;,&quot;fast-math&quot;,&quot;unroll-loops&quot;,&quot;no-stack-protector&quot;)
#pragma GCC diagnostic error &quot;-fwhole-program&quot;
#pragma GCC diagnostic error &quot;-fcse-skip-blocks&quot;
#pragma GCC diagnostic error &quot;-funsafe-loop-optimizations&quot;
#include&lt;bits/stdc++.h&gt;
using namespace std;
#define getchar() (p1==p2&amp;&amp;(p2=(p1=buf)+fread(buf,1,1&lt;&lt;21,stdin),p1==p2)?EOF:*p1++)
char buf[1&lt;&lt;23],*p1=buf,*p2=buf,obuf[1&lt;&lt;23],*O=obuf;

const int N=100010;
const int M=35000;
typedef long long ll;
int n,m,k,cnt,block,bel[N];
ll a[N],ans[N],d1[N],d2[N],c[N],valid[N];

struct Query{
	int l,r,id;ll ans;
	inline bool operator &lt;(const Query&amp; that)const{
		return bel[l]==bel[that.l] ? bel[l]&amp;1 ?
			r&lt;that.r : r&gt;that.r : l&lt;that.l ;
	}
}q[N];
vector&lt;Query&gt;ml[N],mr[N];

inline int g()
{
	register ll res=0,fix=1;
	char ch;
	while(!isdigit(ch=getchar()))
		fix=(ch=='-')?-1:fix;
	do res=res*10+(ch^'0');
	while(isdigit(ch=getchar()));
	return fix*res;
}

inline void out(ll x)
{
	if(x&lt;0)putchar('-'),x=-x;
	if(x&gt;9)out(x/10);
	putchar(x%10+'0');
}

inline void update(int x)
{
	for(int i=1;i&lt;=cnt;i++)
		c[x^valid[i]]++;
}

int main()
{
	n=g(),m=g(),k=g();
	for(register int i=0;i&lt;16390;i++)
		if(__builtin_popcount(i)==k)valid[++cnt]=i;
	for(register int i=1;i&lt;=n;i++)a[i]=g();
	for(register int i=1;i&lt;=m;i++)
		q[i].l=g(),q[i].r=g(),q[i].id=i;
	block=(int)sqrt(n);
	for(register int i=1;i&lt;=n;i++)
		bel[i]=(i-1)/block+1;
	for(register int i=1;i&lt;=n;i++)d1[i]=c[a[i]],update(a[i]);
	memset(c,0,sizeof(c));
	for(register int i=n;i;i--)d2[i]=c[a[i]],update(a[i]);
	memset(c,0,sizeof(c));
	sort(q+1,q+1+m);
	int l=1,r=0;
	for(register int i=1,L,R;i&lt;=m;i++)
	{
		L=q[i].l,R=q[i].r;
		if(r&lt;R)ml[l-1].push_back((Query){r+1,R,i,-1});
		while(r&lt;R)q[i].ans+=d1[++r];
		if(r&gt;R)ml[l-1].push_back((Query){R+1,r,i,1});
		while(r&gt;R)q[i].ans-=d1[r--];
		if(l&lt;L)mr[r+1].push_back((Query){l,L-1,i,1});
		while(l&lt;L)q[i].ans-=d2[l++];
		if(l&gt;L)mr[r+1].push_back((Query){L,l-1,i,-1});
		while(l&gt;L)q[i].ans+=d2[--l];
	}
	for(register int i=1;i&lt;=n;i++)
	{
		update(a[i]);
		for(auto tem:ml[i])
			for(int j=tem.l;j&lt;=tem.r;j++)
				q[tem.id].ans+=tem.ans*c[a[j]]; 
	}
	memset(c,0,sizeof(c));
	for(register int i=n;i;i--)
	{
		update(a[i]);
		for(auto tem:mr[i])
			for(int j=tem.l;j&lt;=tem.r;j++)
				q[tem.id].ans+=tem.ans*c[a[j]];
	}
	for(register int i=1;i&lt;=m;i++)
		q[i].ans+=q[i-1].ans;
	for(register int i=1;i&lt;=m;i++)
		ans[q[i].id]=q[i].ans;
	for(register int i=1;i&lt;=m;i++)out(ans[i]),putchar('\n');
	return 0;
}
</code></pre>
<p>有两个点死活卡不过 不卡了</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[最小度限制生成树]]></title>
        <id>https://rainyclementine.github.io/post/zui-xiao-du-xian-zhi-sheng-cheng-shu</id>
        <link href="https://rainyclementine.github.io/post/zui-xiao-du-xian-zhi-sheng-cheng-shu">
        </link>
        <updated>2019-11-13T00:10:18.000Z</updated>
        <content type="html"><![CDATA[<p>给你一个有<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>个节点<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span>条边的带权无向图 你需要求得一个生成树<br>
使边权总和最小 且满足编号为s的节点正好(或是最多)连<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>条边</p>
<p>解法一 破圈<br>
先将<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">s</span></span></span></span>点和其他点断开 对形成的连通块做<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi><mi>r</mi><mi>u</mi><mi>s</mi><mi>k</mi><mi>a</mi><mi>l</mi></mrow><annotation encoding="application/x-tex">kruskal</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">u</span><span class="mord mathdefault">s</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span></span></span></span><br>
如果连通块数量<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi><mo>&gt;</mo><mi>k</mi></mrow><annotation encoding="application/x-tex">m&gt;k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span> 显然无解<br>
从<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">s</span></span></span></span>点向每个连通块连一条最短的边<br>
再枚举一条和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">s</span></span></span></span>相连的非树边<br>
向求严格次小生成树那样 用这条边替换形成的环上最长的边<br>
重复执行<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi><mo>−</mo><mi>k</mi></mrow><annotation encoding="application/x-tex">m-k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>次 或者不能使答案更优<br>
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>P</mi><mi>O</mi><mi>J</mi><mn>1639</mn><mi>P</mi><mi>i</mi><mi>c</mi><mi>n</mi><mi>i</mi><mi>c</mi><mi>P</mi><mi>l</mi><mi>a</mi><mi>n</mi><mi>n</mi><mi>i</mi><mi>n</mi><mi>g</mi></mrow><annotation encoding="application/x-tex">POJ1639 Picnic Planning</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mord mathdefault" style="margin-right:0.09618em;">J</span><span class="mord">1</span><span class="mord">6</span><span class="mord">3</span><span class="mord">9</span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mord mathdefault">i</span><span class="mord mathdefault">c</span><span class="mord mathdefault">n</span><span class="mord mathdefault">i</span><span class="mord mathdefault">c</span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">a</span><span class="mord mathdefault">n</span><span class="mord mathdefault">n</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span></span></span></span></p>
<pre><code class="language-cpp">#include&lt;algorithm&gt;
#include&lt;cstring&gt;
#include&lt;cstdio&gt;
#include&lt;string&gt;
#include&lt;map&gt;
using namespace std;

const int N=1010;
int n,m,k,tot,head[N];
int inf,a[N][N],b[N][N],fa[N],d[N],v[N];
map&lt;string,int&gt;M;
struct Edge{
	int x,y,z;
	inline bool operator &lt;(const Edge&amp; that)const{
		return z&lt;that.z;
	}
}e[N],f[N];

inline int discrete(string s){return M[s]?M[s]:M[s]=++n;}
inline int find(int x){return x==fa[x]?x:fa[x]=find(fa[x]);}
inline void dfs(int x,int fat)
{
	for(int i=2;i&lt;=n;i++)
	{
		if(i==fat || !b[x][i])continue;
		if(f[i].z==-1)
		{
			if(f[x].z&gt;a[x][i])f[i]=f[x];
			else
			{
				f[i].x=x;
				f[i].y=i;
				f[i].z=a[x][i];
			}
		}
		dfs(i,x);
	}
}

int main()
{
	scanf(&quot;%d&quot;,&amp;m);
	discrete(&quot;Park&quot;);
	memset(a,0x3f,sizeof(a));
	inf=a[0][0];
	memset(d,0x3f,sizeof(d));
	char x[N],y[N];
	for(int i=1;i&lt;=m;i++)
	{
		scanf(&quot;%s%s%d&quot;,x,y,&amp;e[i].z);
		e[i].x=discrete(x);e[i].y=discrete(y);
		a[e[i].x][e[i].y]=a[e[i].y][e[i].x]=min(a[e[i].x][e[i].y],e[i].z);
	}
	for(int i=1;i&lt;=n;i++)
		fa[i]=i;
	int sum=0;
	scanf(&quot;%d&quot;,&amp;k);
	sort(e+1,e+1+m);
	for(int i=1;i&lt;=m;i++)
	{
		if(e[i].x==1 || e[i].y==1)continue;
		int fx=find(e[i].x);
		int fy=find(e[i].y);
		if(fx==fy)continue;
		fa[fy]=fx;
		b[e[i].x][e[i].y]=b[e[i].y][e[i].x]=1;
		sum+=e[i].z;
	}
	for(int i=2;i&lt;=n;i++)
		if(a[1][i]!=inf)
		{
			int root=find(i);
			if(d[root]&gt;a[1][i])d[root]=a[1][v[root]=i];
		}
	for(int i=1;i&lt;=n;i++)
		if(d[i]!=inf)
		{
			k--;
			b[1][v[i]]=b[v[i]][1]=1;
			sum+=a[1][v[i]];
		}
	while(k--)
	{
		memset(f,-1,sizeof(f));
		f[1].z=-inf;
		for(int i=2;i&lt;=n;i++)
			if(b[1][i])f[i].z=-inf;
		dfs(1,-1);
		int pos,maxi=-inf;
		for(int i=2;i&lt;=n;i++)
			if(maxi&lt;f[i].z-a[1][i])
				maxi=f[i].z-a[1][pos=i];
		if(maxi&lt;=0)break;
		b[1][pos]=b[pos][1]=1;
		b[f[pos].x][f[pos].y]=b[f[pos].y][f[pos].x]=0;
		sum-=maxi;
	}
	printf(&quot;Total miles driven: %d\n&quot;,sum);
	return 0;
}
</code></pre>
<p>解法二 带权二分<br>
在<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi><mi>r</mi><mi>u</mi><mi>s</mi><mi>k</mi><mi>a</mi><mi>l</mi></mrow><annotation encoding="application/x-tex">kruskal</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">u</span><span class="mord mathdefault">s</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span></span></span></span>对边排序时 对所有与s相连的边加上一个权值<br>
二分这个权值 使得在<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>M</mi><mi>S</mi><mi>T</mi></mrow><annotation encoding="application/x-tex">MST</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span></span></span></span>中与<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">s</span></span></span></span>相连的边就是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>条<br>
注意 如果在二分边界已经收敛 但是和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">s</span></span></span></span>相连的边数还是大于<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span><br>
那么最后再计算一次答案 本次计算答案时 如果和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">s</span></span></span></span>相连的边已经等于<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span><br>
那么之后只连不和s相连的边<br>
注意特判无解情况<br>
一是和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">s</span></span></span></span>相连的点小于<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span><br>
二是<span class='katex-error' title='ParseError: KaTeX parse error: Expected &#039;EOF&#039;, got &#039;&amp;&#039; at position 5: n&gt;1 &amp;̲&amp; !k'>n&gt;1 &amp;&amp; !k</span><br>
三是生不成一棵树<br>
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>C</mi><mi>F</mi><mn>125</mn><mi>E</mi><mi>M</mi><mi>S</mi><mi>T</mi><mi>C</mi><mi>o</mi><mi>m</mi><mi>p</mi><mi>a</mi><mi>n</mi><mi>y</mi></mrow><annotation encoding="application/x-tex">CF125E MST Company</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mord">1</span><span class="mord">2</span><span class="mord">5</span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mord mathdefault">o</span><span class="mord mathdefault">m</span><span class="mord mathdefault">p</span><span class="mord mathdefault">a</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span></p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;

const int N=50010;
const int M=500010;
const double eps=0.1;
typedef long long ll;
int n,m,k,s,sum,cap,top,fa[N],id[M],stk[M];
ll ans;

struct Node{
	int x,y,z;
	inline bool operator &lt;(const Node&amp; that)const{
		return z&lt;that.z;
	}
}a[M];

double wet;
inline bool cmp(const int&amp; p,const int&amp; q){
	double lw=a[p].z,rw=a[q].z;
	if(a[p].x==s || a[p].y==s)lw+=wet;
	if(a[q].x==s || a[q].y==s)rw+=wet;
	return lw&lt;rw;
}

inline int find(int x){return x==fa[x]?x:fa[x]=find(fa[x]);}
inline void valid(bool op)
{
	sum=cap=top=0;
	for(int i=1;i&lt;=n;i++)fa[i]=i;
	sort(id+1,id+1+m,cmp);
	for(int i=1,fx,fy;i&lt;=m;i++)
	{
		fx=find(a[id[i]].x),fy=find(a[id[i]].y);
		if(fx==fy)continue;
		if(a[id[i]].x==s || a[id[i]].y==s)cap++;
		if(op &amp;&amp; cap&gt;k){cap--;continue;}
		fa[fx]=fy;stk[++top]=id[i];
		if(++sum==n-1)return;
	}
}

int main()
{
	scanf(&quot;%d%d%d%d&quot;,&amp;n,&amp;m,&amp;k);s=1;
	int ind=0;
	for(int i=1;i&lt;=m;i++)
	{
		scanf(&quot;%d%d%d&quot;,&amp;a[i].x,&amp;a[i].y,&amp;a[i].z);
		if(a[i].x==s || a[i].y==s)ind++;
	}
	if(ind&lt;k || (n&gt;1 &amp;&amp; !k)){puts(&quot;Impossible&quot;);return 0;}
	for(int i=1;i&lt;=m;i++)id[i]=i;
	valid(0);
	if(sum&lt;n-1){puts(&quot;Impossible&quot;);return 0;}
	double l=-1e5,r=1e5+0.5;
	while(1)
	{
		if(cap==k)break;
		if(l+eps&gt;r &amp;&amp; cap&gt;k)break;
		double mid=(l+r)/2;
		wet=mid;
		valid(0);
		if(cap&lt;k)r=mid;
		else l=mid;
	}
	if(cap!=k)valid(1);
	for(int i=1;i&lt;=top;i++)
		ans+=1ll*a[stk[i]].z;
	printf(&quot;%lld\n&quot;,ans);
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[HDOJ4348 To the moon 标记永久化]]></title>
        <id>https://rainyclementine.github.io/post/hdoj4348-to-the-moon-biao-ji-yong-jiu-hua</id>
        <link href="https://rainyclementine.github.io/post/hdoj4348-to-the-moon-biao-ji-yong-jiu-hua">
        </link>
        <updated>2019-11-07T03:36:41.000Z</updated>
        <content type="html"><![CDATA[<p>维护一个数列 支持四种操作<br>
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>C</mi><mi>l</mi><mi>r</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">C l r d</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">d</span></span></span></span>区间<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>[</mo><mi>l</mi><mo separator="true">,</mo><mi>r</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">[l,r]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mclose">]</span></span></span></span>中的数都加<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi></mrow><annotation encoding="application/x-tex">d</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">d</span></span></span></span> 同时当前的时间戳加<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span><br>
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>Q</mi><mi>l</mi><mi>r</mi></mrow><annotation encoding="application/x-tex">Q l r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">Q</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span></span></span></span>查询当前时间戳区间<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>[</mo><mi>l</mi><mo separator="true">,</mo><mi>r</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">[l,r]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mclose">]</span></span></span></span>中所有数的和<br>
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>H</mi><mi>l</mi><mi>r</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">H l r t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.08125em;">H</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">t</span></span></span></span>查询时间戳<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault">t</span></span></span></span>区间<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>[</mo><mi>l</mi><mo separator="true">,</mo><mi>r</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">[l,r]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mclose">]</span></span></span></span>的和<br>
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">B t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mord mathdefault">t</span></span></span></span>将当前时间戳置为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault">t</span></span></span></span><br>
所有操作均合法 刚开始时时间戳为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span></p>
<p>先来看普通线段树的标记永久化</p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
#define int long long 

const int N=100010;
int n,m;
struct SegmentTree{
	int sum,add;
	#define sum(x) t[x].sum
	#define add(x) t[x].add
}t[N&lt;&lt;2];

inline void build(int p,int l,int r)
{
	if(l==r)return scanf(&quot;%lld&quot;,&amp;sum(p)),void();
	int mid=l+r&gt;&gt;1;
	build(p&lt;&lt;1,l,mid),build(p&lt;&lt;1|1,mid+1,r);
	sum(p)=sum(p&lt;&lt;1)+sum(p&lt;&lt;1|1);
}

inline void change(int p,int l,int r,int L,int R,int val)
{
	if(L&lt;=l &amp;&amp; r&lt;=R)return add(p)+=val,sum(p)+=(r-l+1)*val,void();
	int mid=l+r&gt;&gt;1;
	if(L&lt;=mid)change(p&lt;&lt;1,l,mid,L,R,val);
	if(R&gt;mid)change(p&lt;&lt;1|1,mid+1,r,L,R,val);
	sum(p)=sum(p&lt;&lt;1)+sum(p&lt;&lt;1|1)+(r-l+1)*add(p);
} 

inline int query(int p,int l,int r,int L,int R,int ad)
{
	if(L&lt;=l &amp;&amp; r&lt;=R)return sum(p)+(r-l+1)*ad;
	int mid=l+r&gt;&gt;1,res=0;
	if(L&lt;=mid)res+=query(p&lt;&lt;1,l,mid,L,R,ad+add(p));
	if(R&gt;mid)res+=query(p&lt;&lt;1|1,mid+1,r,L,R,ad+add(p));
	return res;
}

signed main()
{
	scanf(&quot;%lld%lld&quot;,&amp;n,&amp;m);
	build(1,1,n);
	int op,x,y,z;
	while(m--)
	{
		scanf(&quot;%lld%lld%lld&quot;,&amp;op,&amp;x,&amp;y);
		if(op==1)scanf(&quot;%lld&quot;,&amp;z),change(1,1,n,x,y,z);
		else printf(&quot;%lld\n&quot;,query(1,1,n,x,y,0));
	}
	return 0;
}
</code></pre>
<p>那么对于主席树来说<br>
标记不下放 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi><mi>u</mi><mi>s</mi><mi>h</mi><mi>u</mi><mi>p</mi></mrow><annotation encoding="application/x-tex">pushup</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span><span class="mord mathdefault">u</span><span class="mord mathdefault">s</span><span class="mord mathdefault">h</span><span class="mord mathdefault">u</span><span class="mord mathdefault">p</span></span></span></span>时写成<br>
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mi>u</mi><mi>m</mi><mo>(</mo><mi>q</mi><mo>)</mo><mo>=</mo><mi>s</mi><mi>u</mi><mi>m</mi><mo>(</mo><mi>l</mi><mo>(</mo><mi>q</mi><mo>)</mo><mo>)</mo><mo>+</mo><mi>s</mi><mi>u</mi><mi>m</mi><mo>(</mo><mi>r</mi><mo>(</mo><mi>q</mi><mo>)</mo><mo>)</mo><mo>+</mo><mn>1</mn><mi>l</mi><mi>l</mi><mo>∗</mo><mo>(</mo><mi>r</mi><mo>−</mo><mi>l</mi><mo>+</mo><mn>1</mn><mo>)</mo><mo>∗</mo><mi>a</mi><mi>d</mi><mi>d</mi><mo>(</mo><mi>q</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">sum(q)=sum(l(q))+sum(r(q))+1ll*(r-l+1)*add(q)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="mclose">)</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="mclose">)</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault">d</span><span class="mord mathdefault">d</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="mclose">)</span></span></span></span><br>
这样每个点的<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mi>u</mi><mi>m</mi></mrow><annotation encoding="application/x-tex">sum</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span></span></span></span> 就累积了它的下面节点的<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mi>d</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">add</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault">d</span><span class="mord mathdefault">d</span></span></span></span>的影响<br>
查询时 维护一个<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">ad</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault">d</span></span></span></span> 表示从跟到当前节点打了多少<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mi>d</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">add</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault">d</span><span class="mord mathdefault">d</span></span></span></span>标记<br>
返回<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mi>u</mi><mi>m</mi></mrow><annotation encoding="application/x-tex">sum</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span></span></span></span>时 要加上<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mi>d</mi><mo>∗</mo><mo>(</mo><mi>r</mi><mo>−</mo><mi>l</mi><mo>+</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">ad*(r-l+1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span> 这就累计了这个点上面的节点的<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mi>d</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">add</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault">d</span><span class="mord mathdefault">d</span></span></span></span>的影响</p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;

const int N=100010;
typedef long long ll;
int n,m,tot,tim,root[N];
struct SegmentTree{
	int l,r;ll sum,add;
	#define l(x) t[x].l
	#define r(x) t[x].r
	#define sum(x) t[x].sum
	#define add(x) t[x].add
}t[N*40];

inline void insert(int p,int &amp;q,int l,int r,int d,int val)
{
	if(!q)q=++tot;
	if(l==r)return sum(q)=val,void();
	int mid=l+r&gt;&gt;1;
	if(d&lt;=mid)insert(l(p),l(q),l,mid,d,val),r(q)=r(p);
	if(d&gt;mid)insert(r(p),r(q),mid+1,r,d,val),l(q)=l(p);
	sum(q)=sum(l(q))+sum(r(q))+1ll*(r-l+1)*add(q);
}

inline void change(int p,int &amp;q,int l,int r,int L,int R,ll val)
{
	q=++tot;t[q]=t[p];
	if(L&lt;=l &amp;&amp; r&lt;=R)return add(q)+=val,sum(q)+=1ll*(r-l+1)*val,void();
	int mid=l+r&gt;&gt;1;
	if(L&lt;=mid)change(l(p),l(q),l,mid,L,R,val);
	if(R&gt;mid)change(r(p),r(q),mid+1,r,L,R,val);
	sum(q)=sum(l(q))+sum(r(q))+1ll*(r-l+1)*add(q);
}

inline ll query(int p,int l,int r,int L,int R,ll ad)
{
	if(L&lt;=l &amp;&amp; r&lt;=R)return sum(p)+1ll*(r-l+1)*ad;
	int mid=l+r&gt;&gt;1;ll res=0;
	if(L&lt;=mid)res+=query(l(p),l,mid,L,R,ad+add(p));
	if(R&gt;mid)res+=query(r(p),mid+1,r,L,R,ad+add(p));
	return res;
}

signed main()
{
	while(~scanf(&quot;%d%d&quot;,&amp;n,&amp;m))
	{
		tim=tot=0;
		memset(t,0,sizeof(t));
		memset(root,0,sizeof(root));
		for(int i=1,pos;i&lt;=n;i++)
			scanf(&quot;%d&quot;,&amp;pos),insert(root[0],root[0],1,n,i,pos);
		char op[5];int x,y,z,tim=0;ll w;
		for(int i=1;i&lt;=m;i++)
		{
			scanf(&quot;%s%d&quot;,op,&amp;x);
			if(op[0]=='C')scanf(&quot;%d%lld&quot;,&amp;y,&amp;w),tim++,
				change(root[tim-1],root[tim],1,n,x,y,w);
			else if(op[0]=='Q')scanf(&quot;%d&quot;,&amp;y),
				printf(&quot;%lld\n&quot;,query(root[tim],1,n,x,y,0));
			else if(op[0]=='H')scanf(&quot;%d%d&quot;,&amp;y,&amp;z),
				printf(&quot;%lld\n&quot;,query(root[z],1,n,x,y,0));
			else tim=x;
		}
	}
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[CF893F Subtree Minimum Query 线段树合并 主席树]]></title>
        <id>https://rainyclementine.github.io/post/cf893f-subtree-minimum-query-xian-duan-shu-he-bing-zhu-xi-shu</id>
        <link href="https://rainyclementine.github.io/post/cf893f-subtree-minimum-query-xian-duan-shu-he-bing-zhu-xi-shu">
        </link>
        <updated>2019-11-05T09:27:14.000Z</updated>
        <content type="html"><![CDATA[<p>给你一颗有根树 点有权值 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span>次询问<br>
每次问你某个点的子树中距离其不超过<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>的点的权值的最小值<br>
边权均为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 强制在线</p>
<p>主席树:<br>
线段树下标代表<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>f</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">dfs</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">s</span></span></span></span>序 时间轴是深度<br>
每次查询<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mo>[</mo><mi>x</mi><mo>]</mo><mo>+</mo><mi>k</mi></mrow><annotation encoding="application/x-tex">d[x]+k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mopen">[</span><span class="mord mathdefault">x</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>这棵主席树的<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>[</mo><mi>d</mi><mi>f</mi><mi>n</mi><mo>[</mo><mi>x</mi><mo>]</mo><mo separator="true">,</mo><mi>l</mi><mi>o</mi><mi>w</mi><mo>[</mo><mi>x</mi><mo>]</mo><mo>]</mo></mrow><annotation encoding="application/x-tex">[dfn[x],low[x]]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault">d</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">n</span><span class="mopen">[</span><span class="mord mathdefault">x</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mopen">[</span><span class="mord mathdefault">x</span><span class="mclose">]</span><span class="mclose">]</span></span></span></span>区间<br>
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>f</mi><mi>n</mi></mrow><annotation encoding="application/x-tex">dfn</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">n</span></span></span></span>序自然就限制了深度 所以就正好是那几个点</p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
#define int long long 

const int N=100010;
const int M=1000010;
int n,m,tot,tim,cnt,rt,head[N],dfn[N],low[N],d[N],root[N],siz[N],id[N];
struct Edge{
	int suiv,ver;
}e[M&lt;&lt;1];

struct SegmentTree{
	int l,r,mini;
	SegmentTree(){mini=1000000010;}
	#define l(x) t[x].l
	#define r(x) t[x].r
	#define mini(x) t[x].mini
}t[N*50];

struct Node{
	int val,id,dep;
	inline bool operator &lt;(const Node&amp; that)const{
		return dep&lt;that.dep;
	}
}a[N];
inline bool cmp(int x,int y){return d[x]&lt;d[y];}
inline void lnk(int x,int y)
{
	e[++tot].ver=y;
	e[tot].suiv=head[x];
	head[x]=tot;
}

inline void dfs(int x,int fa)
{
	d[x]=a[x].dep=d[fa]+1;
	dfn[x]=++tim;
	for(int i=head[x];i;i=e[i].suiv)
	{
		int y=e[i].ver;
		if(y==fa)continue;
		dfs(y,x);
	}
	low[x]=tim;
}

inline void insert(int p,int &amp;q,int l,int r,int d,int val)
{
	q=++cnt;
	if(l==r)return mini(q)=min(mini(p),val),void();
	int mid=l+r&gt;&gt;1;
	if(d&lt;=mid)insert(l(p),l(q),l,mid,d,val),r(q)=r(p);
	if(d&gt;mid)insert(r(p),r(q),mid+1,r,d,val),l(q)=l(p);
	mini(q)=min(mini(l(q)),mini(r(q)));
}

inline int query(int p,int l,int r,int L,int R)
{
	if(L&lt;=l &amp;&amp; r&lt;=R)return mini(p);
	int mid=l+r&gt;&gt;1,res=1ll&lt;&lt;60;
	if(L&lt;=mid)res=min(res,query(l(p),l,mid,L,R));
	if(R&gt;mid)res=min(res,query(r(p),mid+1,r,L,R));
	return res;
}

signed main()
{
	scanf(&quot;%lld%lld&quot;,&amp;n,&amp;rt);
	for(int i=1;i&lt;=n;i++)
		scanf(&quot;%lld&quot;,&amp;a[i].val),a[i].id=i;
	for(int i=1,x,y;i&lt;n;i++)
		scanf(&quot;%lld%lld&quot;,&amp;x,&amp;y),lnk(x,y),lnk(y,x);
	dfs(rt,0);sort(a+1,a+1+n);
	for(int i=1;i&lt;=n;i++)
		insert(root[a[i-1].dep],root[a[i].dep],1,n,dfn[a[i].id],a[i].val);
	scanf(&quot;%lld&quot;,&amp;m);
	int x,y,ans=0;
	while(m--)
	{
		scanf(&quot;%lld%lld&quot;,&amp;x,&amp;y);
		x=(x+ans)%n+1,y=(y+ans)%n;
		printf(&quot;%lld\n&quot;,ans=query(root[min(d[x]+y,a[n].dep)],1,n,dfn[x],low[x]));
	}
	return 0;
}
</code></pre>
<p>线段树合并:<br>
下标代表深度 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi><mi>i</mi><mi>n</mi><mi>i</mi></mrow><annotation encoding="application/x-tex">mini</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault">i</span></span></span></span>维护点权最小值<br>
因为要求在线 所以每次新建节点</p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
#define int long long 

const int N=100010;
const int M=1000010;
int n,m,tot,cnt,rt,head[N],d[N],root[N],a[N];
struct Edge{
	int suiv,ver;
}e[M&lt;&lt;1];

struct SegmentTree{
	int l,r,mini;
	SegmentTree(){mini=1000000010;}
	#define l(x) t[x].l
	#define r(x) t[x].r
	#define mini(x) t[x].mini
}t[N*50];

inline void lnk(int x,int y)
{
	e[++tot].ver=y;
	e[tot].suiv=head[x];
	head[x]=tot;
}

inline void insert(int &amp;p,int l,int r,int d,int val)
{
	if(!p)p=++cnt;
	if(l==r)return mini(p)=min(mini(p),val),void();
	int mid=l+r&gt;&gt;1;
	if(d&lt;=mid)insert(l(p),l,mid,d,val);
	if(d&gt;mid)insert(r(p),mid+1,r,d,val);
	mini(p)=min(mini(l(p)),mini(r(p)));
}

inline int merge(int x,int y,int l,int r)
{
	if(!x || !y)return x^y;
	int p=++cnt;
	if(l==r)return mini(p)=min(mini(x),mini(y)),p;
	int mid=l+r&gt;&gt;1;
	l(p)=merge(l(x),l(y),l,mid);
	r(p)=merge(r(x),r(y),mid+1,r);
	mini(p)=min(mini(l(p)),mini(r(p)));
	return p;
}

inline int query(int p,int l,int r,int L,int R)
{
    if((L&lt;=l &amp;&amp; r&lt;=R)||!p)return mini(p);
    int mid=l+r&gt;&gt;1,res=1ll&lt;&lt;60;
    if(L&lt;=mid)res=min(res,query(l(p),l,mid,L,R));
    if(R&gt;mid)res=min(res,query(r(p),mid+1,r,L,R));
    return res;
}

inline void dfs(int x,int fa)
{
    d[x]=d[fa]+1;
    insert(root[x],1,n,d[x],a[x]);
	for(int i=head[x];i;i=e[i].suiv)
	{
		int y=e[i].ver;
		if(y==fa)continue;
		dfs(y,x);
        root[x]=merge(root[x],root[y],1,n); 
	}
}

signed main()
{
	scanf(&quot;%lld%lld&quot;,&amp;n,&amp;rt);
	for(int i=1;i&lt;=n;i++)
		scanf(&quot;%lld&quot;,&amp;a[i]);
	for(int i=1,x,y;i&lt;n;i++)
		scanf(&quot;%lld%lld&quot;,&amp;x,&amp;y),lnk(x,y),lnk(y,x);
	dfs(rt,0);
    scanf(&quot;%lld&quot;,&amp;m);
    int x,y,ans=0;
    while(m--)
    {
        scanf(&quot;%lld%lld&quot;,&amp;x,&amp;y);
        x=(x+ans)%n+1,y=(y+ans)%n;
		printf(&quot;%lld\n&quot;,ans=query(root[x],1,n,d[x],min(d[x]+y,n)));
    }
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[FJOI2014 最短路径树问题 点分治]]></title>
        <id>https://rainyclementine.github.io/post/fjoi2014-zui-duan-lu-jing-shu-wen-ti-dian-fen-zhi</id>
        <link href="https://rainyclementine.github.io/post/fjoi2014-zui-duan-lu-jing-shu-wen-ti-dian-fen-zhi">
        </link>
        <updated>2019-10-25T03:39:40.000Z</updated>
        <content type="html"><![CDATA[<p>给定个一张无向图 有边权 求出<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>t</mi><mi>a</mi></mrow><annotation encoding="application/x-tex">ta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault">t</span><span class="mord mathdefault">a</span></span></span></span>的以<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>为源点的字典序最小的最短路树<br>
问在这棵树上包含<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>个点的最长的路径的长度 以及个数</p>
<p>求最短路树的时候 在<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>i</mi><mi>j</mi><mi>k</mi><mi>s</mi><mi>t</mi><mi>r</mi><mi>a</mi></mrow><annotation encoding="application/x-tex">dijkstra</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">a</span></span></span></span>的时候记录每个点的前驱就可以了<br>
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>[</mo><mi>i</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">f[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span></span></span></span>表示当前遍历到的子树内深度为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span>的最长路径长度<br>
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>g</mi><mo>[</mo><mi>i</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">g[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span></span></span></span>表示之前遍历到的子树内深度为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span>的最长路径长度<br>
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi><mi>n</mi><mi>t</mi><mi>f</mi><mo>[</mo><mi>i</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">cntf[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault">n</span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span></span></span></span>表示当前遍历到的子树内深度为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span>的最长路径的个数<br>
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi><mi>n</mi><mi>t</mi><mi>g</mi><mo>[</mo><mi>i</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">cntg[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault">n</span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span></span></span></span>表示之前遍历到的子树内深度为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span>的最长路径的个数<br>
当前的根算路径上一个点 那么<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>[</mo><mi>k</mi><mo>−</mo><mn>1</mn><mo>−</mo><mi>j</mi><mo>]</mo><mo>+</mo><mi>g</mi><mo>[</mo><mi>j</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">f[k-1-j]+g[j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span>更新最长长度<br>
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi><mi>n</mi><mi>t</mi><mi>f</mi><mo>[</mo><mi>k</mi><mo>−</mo><mn>1</mn><mo>−</mo><mi>j</mi><mo>]</mo><mo>∗</mo><mi>c</mi><mi>n</mi><mi>t</mi><mi>g</mi><mo>[</mo><mi>j</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">cntf[k-1-j]*cntg[j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault">n</span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault">n</span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span>更新个数<br>
初值<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi><mi>n</mi><mi>t</mi><mi>g</mi><mo>[</mo><mn>0</mn><mo>]</mo><mo>=</mo><mn>1</mn><mi>c</mi><mi>n</mi><mi>t</mi><mi>f</mi><mo>[</mo><mn>0</mn><mo>]</mo><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">cntg[0]=1 cntf[0]=0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault">n</span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mopen">[</span><span class="mord">0</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord mathdefault">c</span><span class="mord mathdefault">n</span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord">0</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span></p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
#define int long long 

const int N=30010;
const int M=60010;
int n,m,k,root,sum,maxidep,ans,anscnt,inf,maxi[N],siz[N],f[N],g[N],dep[N],dis[N],cntf[N],cntg[N];
bool v[N];
pair&lt;int,int&gt;pre[N];
struct Edge{
	int tot,head[N],suiv[M&lt;&lt;1],ver[M&lt;&lt;1],edge[M&lt;&lt;1],d[N];	
	inline void clear(){tot=1;memset(head,0,sizeof(head));}
	inline void lnk(int x,int y,int z)
	{
		ver[++tot]=y;edge[tot]=z;
		suiv[tot]=head[x];head[x]=tot;
	}
	
	inline void dijkstra(int st)
	{
		priority_queue&lt;pair&lt;int,int&gt; &gt;q;
		memset(d,0x3f,sizeof(d));
		d[st]=0;
		q.push(make_pair(0,st));
		while(q.size())
		{
			int x=q.top().second;q.pop();
			if(v[x])continue;v[x]=1;
			for(int i=head[x];i;i=suiv[i])
			{
				int y=ver[i],z=edge[i];
				if(d[y]&gt;d[x]+z)
				{
					d[y]=d[x]+z;
					pre[y]=make_pair(x,z);
					q.push(make_pair(-d[y],y));
				}
				else if(d[y]==d[x]+z &amp;&amp; pre[y].first&gt;x)
					pre[y]=make_pair(x,z);
			}
		}
	}
}e,re;

inline void getroot(int x,int fa)
{
	siz[x]=1,maxi[x]=0;
	for(int i=re.head[x];i;i=re.suiv[i])
	{
		int y=re.ver[i];
		if(v[y] || y==fa)continue;
		getroot(y,x);
		siz[x]+=siz[y];
		maxi[x]=max(maxi[x],siz[y]);
	}
	maxi[x]=max(maxi[x],sum-siz[x]);
	if(maxi[x]&lt;maxi[root])root=x;
}

int posdep;
inline void getdep(int x,int fa)
{
	if(dis[x]&gt;f[dep[x]])f[dep[x]]=dis[x],cntf[dep[x]]=1;
	else if(dis[x]==f[dep[x]])cntf[dep[x]]++;
	posdep=max(posdep,dep[x]);
	for(int i=re.head[x];i;i=re.suiv[i])
	{
		int y=re.ver[i];
		if(fa==y || v[y])continue;
		dep[y]=dep[x]+1,dis[y]=dis[x]+re.edge[i];
		getdep(y,x);
	}
}

inline void solve(int x)
{
	v[x]=1;
	g[0]=f[0]=maxidep=0;
	cntf[0]=cntg[0]=1;
	for(int i=re.head[x];i;i=re.suiv[i])
	{
		int y=re.ver[i];
		if(v[y])continue;
		posdep=dep[y]=1;dis[y]=re.edge[i];
		f[0]=0;
		cntf[0]=0;
		getdep(y,x);
		maxidep=max(maxidep,posdep);
		for(int j=0;j&lt;=min(k-1,posdep);j++)
		{
			if(g[k-1-j]+f[j]&gt;ans)
				ans=g[k-1-j]+f[j],anscnt=cntg[k-1-j]*cntf[j];
			else if(g[k-1-j]+f[j]==ans)
				anscnt+=cntg[k-1-j]*cntf[j];
		}
		for(int j=0;j&lt;=min(posdep,k-1);j++)
		{
			if(f[j]&gt;g[j])g[j]=f[j],cntg[j]=cntf[j];
			else if(f[j]==g[j])cntg[j]+=cntf[j];
			f[j]=inf,cntf[j]=0;
		}
	}
	for(int i=0;i&lt;=maxidep;i++)
		f[i]=g[i]=inf,cntf[i]=cntg[i]=0;
	for(int i=re.head[x];i;i=re.suiv[i])
	{
		int y=re.ver[i];
		if(v[y])continue;
		root=0;
		sum=siz[y];
		getroot(y,x);
		solve(root);
	}
}

signed main()
{
	scanf(&quot;%lld%lld%lld&quot;,&amp;n,&amp;m,&amp;k);
	for(int i=1,x,y,z;i&lt;=m;i++)
		scanf(&quot;%lld%lld%lld&quot;,&amp;x,&amp;y,&amp;z),e.lnk(x,y,z),e.lnk(y,x,z);
	e.dijkstra(1);
	for(int i=2;i&lt;=n;i++)
		re.lnk(i,pre[i].first,pre[i].second),
		re.lnk(pre[i].first,i,pre[i].second);
	memset(f,0xcf,sizeof(f));
	memset(g,0xcf,sizeof(g));
	inf=f[0];
	maxi[0]=sum=n;
	memset(v,0,sizeof(v));
	getroot(1,0);
	solve(root);	
	printf(&quot;%lld %lld\n&quot;,ans,anscnt);
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[类锯木厂选址三题 斜率优化DP]]></title>
        <id>https://rainyclementine.github.io/post/lei-ju-mu-han-xuan-zhi-san-ti-xie-lu-you-hua-dp</id>
        <link href="https://rainyclementine.github.io/post/lei-ju-mu-han-xuan-zhi-san-ti-xie-lu-you-hua-dp">
        </link>
        <updated>2019-10-17T01:19:17.000Z</updated>
        <content type="html"><![CDATA[<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>C</mi><mi>E</mi><mi>O</mi><mi>I</mi><mn>2004</mn></mrow><annotation encoding="application/x-tex">CEOI2004</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="mord">2</span><span class="mord">0</span><span class="mord">0</span><span class="mord">4</span></span></span></span> 锯木厂选址<br>
山坡上有<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>棵数 每棵树有一个位置<br>
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi></mrow><annotation encoding="application/x-tex">d</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">d</span></span></span></span>i表示离下一棵数的距离<br>
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>w</mi><mi>i</mi></mrow><annotation encoding="application/x-tex">wi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault">i</span></span></span></span>表示树的重量<br>
每棵树会运到<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>t</mi><mi>a</mi></mrow><annotation encoding="application/x-tex">ta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault">t</span><span class="mord mathdefault">a</span></span></span></span>右边离<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>t</mi><mi>a</mi></mrow><annotation encoding="application/x-tex">ta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault">t</span><span class="mord mathdefault">a</span></span></span></span>最近的锯木厂 代价是到锯木厂的距离<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>∗</mo><mi>w</mi><mi>i</mi></mrow><annotation encoding="application/x-tex">*wi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord">∗</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault">i</span></span></span></span><br>
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>的位置已经有一个锯木厂<br>
再修两个锯木厂 最小化代价</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mo>[</mo><mi>i</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">s[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span></span></span></span>表示<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>w</mi><mo>[</mo><mi>i</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">w[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span></span></span></span>的前缀和<br>
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mo>[</mo><mi>i</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">d[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span></span></span></span>表示<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>i</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">dis</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">i</span><span class="mord mathdefault">s</span></span></span></span>的后缀和<br>
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>[</mo><mi>i</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">f[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span></span></span></span>表示第二个锯木厂选址在<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span>的最小代价<br>
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>=</mo><mi>m</mi><mi>i</mi><mi>n</mi><mo>(</mo><mi>s</mi><mi>u</mi><mi>m</mi><mo>−</mo><mi>d</mi><mo>[</mo><mi>j</mi><mo>]</mo><mo>×</mo><mi>s</mi><mo>[</mo><mi>j</mi><mo>]</mo><mo>−</mo><mi>d</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>×</mo><mo>(</mo><mi>s</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>−</mo><mi>s</mi><mo>[</mo><mi>j</mi><mo>]</mo><mo>)</mo><mo>)</mo></mrow><annotation encoding="application/x-tex">f[i]=min(sum-d[j] \times s[j]-d[i]\times(s[i]-s[j]))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mopen">(</span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span></p>
<p>当<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>比<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span>优时 有<br>
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>−</mo><mi>d</mi><mo>[</mo><mi>j</mi><mo>]</mo><mo>×</mo><mi>d</mi><mo>[</mo><mi>j</mi><mo>]</mo><mo>−</mo><mi>d</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>×</mo><mo>(</mo><mi>s</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>−</mo><mi>s</mi><mo>[</mo><mi>j</mi><mo>]</mo><mo>)</mo><mo>&gt;</mo><mo>−</mo><mi>d</mi><mo>[</mo><mi>k</mi><mo>]</mo><mo>×</mo><mi>s</mi><mo>[</mo><mi>k</mi><mo>]</mo><mo>−</mo><mi>d</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>×</mo><mo>(</mo><mi>s</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>−</mo><mi>s</mi><mo>[</mo><mi>k</mi><mo>]</mo><mo>)</mo></mrow><annotation encoding="application/x-tex">-d[j]\times d[j]-d[i]\times(s[i]-s[j])&gt;-d[k]\times s[k]-d[i]\times(s[i]-s[k])</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">−</span><span class="mord mathdefault">d</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">−</span><span class="mord mathdefault">d</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">]</span><span class="mclose">)</span></span></span></span><br>
即 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>d</mi><mo>[</mo><mi>k</mi><mo>]</mo><mo>×</mo><mi>s</mi><mo>[</mo><mi>k</mi><mo>]</mo><mo>−</mo><mi>d</mi><mo>[</mo><mi>j</mi><mo>]</mo><mo>×</mo><mi>s</mi><mo>[</mo><mi>j</mi><mo>]</mo><mo>)</mo><mi mathvariant="normal">/</mi><mo>(</mo><mi>s</mi><mo>[</mo><mi>k</mi><mo>]</mo><mo>+</mo><mi>s</mi><mo>[</mo><mi>j</mi><mo>]</mo><mo>)</mo><mo>&gt;</mo><mi>d</mi><mo>[</mo><mi>i</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">(d[k]\times s[k]-d[j]\times s[j])/(s[k]+s[j]) &gt; d[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">d</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mclose">)</span><span class="mord">/</span><span class="mopen">(</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span></span></span></span><br>
即维护一个下凸包即可</p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;

const int N=20010;
int n,sum,w[N],s[N],d[N],q[N],f[N];

inline double slope(int x,int y){
	return (1.0*d[x]*s[x]-d[y]*s[y])/(1.0*s[x]-s[y]);
}

int main()
{
	scanf(&quot;%d&quot;,&amp;n);
	for(int i=1;i&lt;=n;i++)
		scanf(&quot;%d%d&quot;,&amp;w[i],&amp;d[i]),s[i]=s[i-1]+w[i];
	for(int i=n;i;i--)
		d[i]+=d[i+1],sum+=w[i]*d[i];
	int l=1,r=1;
	for(int i=1;i&lt;=n;i++)
	{
		while(l&lt;r &amp;&amp; slope(q[l],q[l+1])&gt;1.0*d[i])l++;
		f[i]=sum-d[q[l]]*s[q[l]]-d[i]*(s[i]-s[q[l]]);
		while(l&lt;r &amp;&amp; slope(q[r],i)&gt;slope(q[r-1],q[r]))r--;
		q[++r]=i;
	}
	int ans=0x3f3f3f3f;
	for(int i=1;i&lt;=n;i++)
		ans=min(ans,f[i]);
	printf(&quot;%d\n&quot;,ans);
	return 0;
}
</code></pre>
<p>当然 也可以退火<br>
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mo>[</mo><mi>i</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">d[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span></span></span></span> 表示<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span>的距离后缀和<br>
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi><mo>[</mo><mi>i</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">c[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">c</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span></span></span></span>表示<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span>的<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>w</mi><mi>i</mi></mrow><annotation encoding="application/x-tex">wi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault">i</span></span></span></span>的前缀和<br>
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mi>u</mi><mi>m</mi><mo>[</mo><mi>i</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">sum[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span></span></span></span>表示<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span>之前的所有树运到最后一个锯木厂的代价和<br>
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mi>n</mi><mi>s</mi><mo>=</mo><mi>s</mi><mi>u</mi><mi>m</mi><mo>[</mo><mi>x</mi><mo>]</mo><mo>+</mo><mi>s</mi><mi>u</mi><mi>m</mi><mo>[</mo><mi>y</mi><mo>]</mo><mo>−</mo><mi>s</mi><mi>u</mi><mi>m</mi><mo>[</mo><mi>x</mi><mo>]</mo><mo>−</mo><mi>c</mi><mo>[</mo><mi>x</mi><mo>]</mo><mo>×</mo><mo>(</mo><mi>d</mi><mi>i</mi><mi>s</mi><mo>[</mo><mi>y</mi><mo>]</mo><mo>−</mo><mi>d</mi><mi>i</mi><mi>s</mi><mo>[</mo><mi>x</mi><mo>]</mo><mo>)</mo><mo>+</mo><mi>s</mi><mi>u</mi><mi>m</mi><mo>[</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo>]</mo><mo>−</mo><mi>s</mi><mi>u</mi><mi>m</mi><mo>[</mo><mi>y</mi><mo>]</mo><mo>−</mo><mi>c</mi><mo>[</mo><mi>y</mi><mo>]</mo><mo>×</mo><mo>(</mo><mi>d</mi><mi>i</mi><mi>s</mi><mo>[</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo>]</mo><mo>−</mo><mi>d</mi><mi>i</mi><mi>s</mi><mo>[</mo><mi>y</mi><mo>]</mo><mo>)</mo></mrow><annotation encoding="application/x-tex">ans=sum[x]+sum[y]-sum[x]-c[x]\times(dis[y]-dis[x])+sum[n+1]-sum[y]-c[y]\times(dis[n+1]-dis[y])</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault">n</span><span class="mord mathdefault">s</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mopen">[</span><span class="mord mathdefault">x</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mopen">[</span><span class="mord mathdefault">x</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">c</span><span class="mopen">[</span><span class="mord mathdefault">x</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">d</span><span class="mord mathdefault">i</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">i</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault">x</span><span class="mclose">]</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mopen">[</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">c</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">d</span><span class="mord mathdefault">i</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">i</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">]</span><span class="mclose">)</span></span></span></span></p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
#define int long long 

const int N=20010;
typedef long long ll;
const double eps=1e-3;
const double del=0.99;
int n,ans=2000000000,ansA,ansB,sum[N],c[N],dis[N];
struct Node{int d,w;}a[N];

inline double gettime(){return (double)clock()/CLOCKS_PER_SEC;}
inline int cal(int x,int y)
{
	if(x&gt;y)swap(x,y);
	int res=sum[x];
	res+=sum[y]-sum[x]-c[x]*(dis[y]-dis[x]);
	res+=sum[n+1]-sum[y]-c[y]*(dis[n+1]-dis[y]);
	return res;
}

inline void sa()
{
	double tem=1989;
	while(tem&gt;eps)
	{
		int nouA=ansA,nouB=ansB;
		if(rand()%2)
		{
			nouA=ansA+(rand()%n)*(rand()%2?1:-1);
			while(nouA==nouB || nouA&lt;1 || nouA&gt;n)
				nouA=ansA+(rand()%n)*(rand()%2?1:-1);
		}
		else
		{
			nouB=ansB+(rand()%n)*(rand()%2?1:-1);
			while(nouA==nouB || nouB&lt;1 || nouB&gt;n)
				nouB=ansB+(rand()%n)*(rand()%2?1:-1);
		}
		int nouans=cal(nouA,nouB);
		int sub=nouans-ans;
		if(sub&lt;0)
			ansA=nouA,ansB=nouB,ans=nouans;
		else if(exp(-sub/tem)*RAND_MAX&gt;rand())
			ansA=nouA,ansB=nouB;
		tem*=del;
	}
}

signed main()
{
	scanf(&quot;%d&quot;,&amp;n);
	for(int i=1;i&lt;=n;i++)
		scanf(&quot;%d%d&quot;,&amp;a[i].w,&amp;a[i].d);
	for(int i=1;i&lt;=n+1;i++)
		sum[i]=sum[i-1]+c[i-1]*a[i-1].d,
		c[i]=c[i-1]+a[i].w,
		dis[i+1]=dis[i]+a[i].d;
	ansA=rand()%n+1;ansB=rand()%n+1;
	while(ansB==ansA)ansB=rand()%n+1;
	while(gettime()&lt;0.8)sa();
	printf(&quot;%d\n&quot;,ans);
	return 0;
}
</code></pre>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>Z</mi><mi>J</mi><mi>O</mi><mi>I</mi><mn>2007</mn></mrow><annotation encoding="application/x-tex">ZJOI2007</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">Z</span><span class="mord mathdefault" style="margin-right:0.09618em;">J</span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="mord">2</span><span class="mord">0</span><span class="mord">0</span><span class="mord">7</span></span></span></span> 仓库建设<br>
在锯木厂选址的基础上 每个位置修锯木厂有一个代价<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi><mi>i</mi></mrow><annotation encoding="application/x-tex">ci</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault">i</span></span></span></span><br>
且可以修任意个锯木厂</p>
<p>关于快速计算答案:<br>
记一个点到最后一个点的距离为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>i</mi></mrow><annotation encoding="application/x-tex">di</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">i</span></span></span></span><br>
记一个点的树木的前缀和是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mi>i</mi></mrow><annotation encoding="application/x-tex">si</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">i</span></span></span></span><br>
记一个点 包含这个点 和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>t</mi><mi>a</mi></mrow><annotation encoding="application/x-tex">ta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault">t</span><span class="mord mathdefault">a</span></span></span></span>后面所有点运到山脚的代价是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mi>n</mi><mi>s</mi><mi>i</mi></mrow><annotation encoding="application/x-tex">ansi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault">n</span><span class="mord mathdefault">s</span><span class="mord mathdefault">i</span></span></span></span><br>
那么在j已经有一个锯木厂的情况下<br>
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>=</mo><mi>m</mi><mi>i</mi><mi>n</mi><mrow><mi>f</mi><mo>[</mo><mi>j</mi><mo>]</mo><mo>+</mo><mi>a</mi><mi>n</mi><mi>s</mi><mo>[</mo><mi>j</mi><mo>+</mo><mn>1</mn><mo>]</mo><mo>−</mo><mi>a</mi><mi>n</mi><mi>s</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>−</mo><mi>d</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>×</mo><mo>(</mo><mi>s</mi><mo>[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo>]</mo><mo>−</mo><mi>s</mi><mo>[</mo><mi>j</mi><mo>]</mo><mo>)</mo></mrow></mrow><annotation encoding="application/x-tex">f[i]=min{f[j]+ans[j+1]-ans[i]-d[i]\times(s[i-1]-s[j])}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault">n</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault">n</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">d</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mopen">(</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mclose">)</span></span></span></span></span><br>
决策<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span>比<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>优时 有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mi>l</mi><mi>o</mi><mi>p</mi><mi>e</mi><mo>(</mo><mi>j</mi><mo separator="true">,</mo><mi>k</mi><mo>)</mo><mo>&lt;</mo><mi>d</mi><mo>[</mo><mi>i</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">slope(j,k)&lt;d[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault">p</span><span class="mord mathdefault">e</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span></span></span></span></p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
#define int long long 

const int N=1000010;
int n,d[N],w[N],s[N],c[N],ans[N],f[N],q[N];

inline double slope(int x,int y){
	return (1.0*ans[x+1]-ans[y+1]+f[x]-f[y])/(1.0*s[y]-s[x]);
}

signed main()
{
	scanf(&quot;%lld&quot;,&amp;n);
	for(int i=1;i&lt;=n;i++)
		scanf(&quot;%lld%lld%lld&quot;,&amp;d[i],&amp;w[i],&amp;c[i]),s[i]=s[i-1]+w[i];
	for(int i=1;i&lt;=n;i++)
		d[i]=d[n]-d[i];
	for(int i=n;i;i--)
		ans[i]=ans[i+1]+w[i]*d[i];
	int l=1,r=1;
	for(int i=1;i&lt;=n;i++)
	{
		while(l&lt;r &amp;&amp; slope(q[l],q[l+1])&gt;d[i])l++;
		f[i]=f[q[l]]+ans[q[l]+1]-ans[i]-d[i]*(s[i-1]-s[q[l]])+c[i];
		while(l&lt;r &amp;&amp; slope(q[r],q[r-1])&lt;slope(i,q[r]))r--;
		q[++r]=i;
	}
	printf(&quot;%lld\n&quot;,f[n]);
	return 0;
} 
</code></pre>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi><mi>O</mi><mi>I</mi><mi>P</mi><mn>2018</mn></mrow><annotation encoding="application/x-tex">NOIP2018</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mord">2</span><span class="mord">0</span><span class="mord">1</span><span class="mord">8</span></span></span></span> 摆渡车<br>
有<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>个人 每个人开始等车的时刻是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>t</mi><mi>i</mi></mrow><annotation encoding="application/x-tex">ti</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">t</span><span class="mord mathdefault">i</span></span></span></span><br>
车往返一趟的时间是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span> 回来后可以立即出发<br>
求最小的总的等车时间</p>
<p>看了<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>z</mi><mi>h</mi><mi>o</mi><mi>u</mi><mi>t</mi><mi>b</mi><mn>2333</mn></mrow><annotation encoding="application/x-tex">zhoutb2333</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="mord mathdefault">h</span><span class="mord mathdefault">o</span><span class="mord mathdefault">u</span><span class="mord mathdefault">t</span><span class="mord mathdefault">b</span><span class="mord">2</span><span class="mord">3</span><span class="mord">3</span><span class="mord">3</span></span></span></span>的题解后 发现之前记什么前后缀<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mi>n</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">ans</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault">n</span><span class="mord mathdefault">s</span></span></span></span>的做法太<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mi>a</mi><mi>i</mi><mi>v</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">naive</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">a</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault">e</span></span></span></span>了<br>
记<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mi>i</mi></mrow><annotation encoding="application/x-tex">Ti</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault">i</span></span></span></span>为的<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span>次发车时间<br>
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mi>n</mi><mi>s</mi><mo>=</mo><mo>∑</mo><mrow><mo>(</mo><msub><mi>T</mi><mi>i</mi></msub><mo>−</mo><msub><mi>T</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>)</mo><mo>∗</mo><msub><mi>T</mi><mi>i</mi></msub></mrow><mo>−</mo><mo>∑</mo><msub><mi>t</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">ans=\sum{(T_i-T_{i-1})*T_{i}} - \sum{t_{i}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault">n</span><span class="mord mathdefault">s</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.00001em;vertical-align:-0.25001em;"></span><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.00001em;vertical-align:-0.25001em;"></span><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span><br>
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>[</mo><mi>i</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">f[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span></span></span></span>表示到i时刻的最小的前一项和<br>
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>w</mi><mo>[</mo><mi>i</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">w[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span></span></span></span>为i时刻等车人数的前缀和<br>
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>=</mo><mi>m</mi><mi>i</mi><mi>n</mi><mrow><mi>f</mi><mo>[</mo><mi>j</mi><mo>]</mo><mo>+</mo><mo>(</mo><mi>w</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>−</mo><mi>s</mi><mo>[</mo><mi>j</mi><mo>]</mo><msup><mo>)</mo><mn>2</mn></msup></mrow></mrow><annotation encoding="application/x-tex">f[i]=min{f[j]+(w[i]-s[j])^2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span><br>
当<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi><mo>&lt;</mo><mi>j</mi></mrow><annotation encoding="application/x-tex">k&lt;j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.73354em;vertical-align:-0.0391em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span>比<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>优时 有<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mi>l</mi><mi>o</mi><mi>p</mi><mi>e</mi><mo>(</mo><mi>j</mi><mo separator="true">,</mo><mi>k</mi><mo>)</mo><mo>&lt;</mo><mi>i</mi></mrow><annotation encoding="application/x-tex">slope(j,k)&lt;i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault">p</span><span class="mord mathdefault">e</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span></p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std; 
#define int long long 

const int N=110;
const int M=4000010;
int n,m,sum,w[M],ans[M],f[M],q[M];

inline double slope(int x,int y){
	return (1.0*f[x]-f[y])/(1.0*w[x]-w[y]==0?1e-9:1.0*w[x]-w[y]);
}

signed main()
{
	int maxi=0;
	scanf(&quot;%lld%lld&quot;,&amp;n,&amp;m);
	for(int i=1,x;i&lt;=n;i++)
		scanf(&quot;%lld&quot;,&amp;x),w[++x]++,maxi=max(maxi,x),sum+=x;
	maxi+=m;
	for(int i=1;i&lt;=maxi;i++)
		w[i]+=w[i-1];	
	int l=1,r=1,ans=0x7fffffff;
	for(int i=1;i&lt;=maxi;i++)
	{
		if(i-m&gt;0)
		{
			while(l&lt;r &amp;&amp; slope(q[r],q[r-1])&gt;=slope(i-m,q[r]))r--;
			q[++r]=i-m;
		}
		while(l&lt;r &amp;&amp; slope(q[l+1],q[l])&lt;=i)l++;
		f[i]=f[q[l]]+(w[i]-w[q[l]])*i;
	}
	for(int i=maxi;i&gt;=maxi-m;i--)
		ans=min(ans,f[i]);
	printf(&quot;%lld\n&quot;,ans-sum);
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[POI2015 Pustynia 差分约束 线段树优化建图]]></title>
        <id>https://rainyclementine.github.io/post/poi2015-pustynia-chai-fen-yue-shu-xian-duan-shu-you-hua-jian-tu</id>
        <link href="https://rainyclementine.github.io/post/poi2015-pustynia-chai-fen-yue-shu-xian-duan-shu-you-hua-jian-tu">
        </link>
        <updated>2019-10-16T07:21:47.000Z</updated>
        <content type="html"><![CDATA[<p>给定一个长度为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>的数列 每个数的合法取值范围是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>[</mo><mn>1</mn><mo separator="true">,</mo><mn>1</mn><mi>e</mi><mn>9</mn><mo>]</mo></mrow><annotation encoding="application/x-tex">[1,1e9]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord mathdefault">e</span><span class="mord">9</span><span class="mclose">]</span></span></span></span><br>
其中<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">s</span></span></span></span>个数的值是已知的 另外给定<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span>条限制<br>
形如<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mi>r</mi><mi>k</mi><mi>a</mi><mn>1</mn><mi>a</mi><mn>2....</mn><mi>a</mi><mi>k</mi></mrow><annotation encoding="application/x-tex">l r k a1 a2.... ak</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord mathdefault">a</span><span class="mord">1</span><span class="mord mathdefault">a</span><span class="mord">2</span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span><br>
表示在原数列下标为[l,r]的区间中有k个下标为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mn>1</mn><mi>a</mi><mn>2</mn><mi>a</mi><mn>3..</mn><mi>a</mi><mi>k</mi></mrow><annotation encoding="application/x-tex">a1 a2 a3 .. ak</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">a</span><span class="mord">1</span><span class="mord mathdefault">a</span><span class="mord">2</span><span class="mord mathdefault">a</span><span class="mord">3</span><span class="mord">.</span><span class="mord">.</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span> 的数<br>
它比[l,r]这区间中除了这k个数的数都严格大于<br>
构造一组可行解 无解输出NIE</p>
<p>每个数向比<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>t</mi><mi>a</mi></mrow><annotation encoding="application/x-tex">ta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault">t</span><span class="mord mathdefault">a</span></span></span></span>小的数连一条权值为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>的边 线段树优化建图<br>
显然 有环无解<br>
开始拓补排序 将没有初始值的点的<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mo>[</mo><mo>]</mo></mrow><annotation encoding="application/x-tex">d[]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mopen">[</span><span class="mclose">]</span></span></span></span>设为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi><mi>n</mi><mi>f</mi></mrow><annotation encoding="application/x-tex">inf</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span></span></span></span> 否则就是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>t</mi><mi>a</mi></mrow><annotation encoding="application/x-tex">ta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault">t</span><span class="mord mathdefault">a</span></span></span></span>的已知的值<br>
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mo>[</mo><mi>y</mi><mo>]</mo><mo>=</mo><mi>m</mi><mi>i</mi><mi>n</mi><mo>(</mo><mi>d</mi><mo>[</mo><mi>y</mi><mo>]</mo><mo separator="true">,</mo><mi>d</mi><mo>[</mo><mi>x</mi><mo>]</mo><mo>−</mo><mi>e</mi><mi>d</mi><mi>g</mi><mi>e</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">d[y]=min(d[y],d[x]-edge)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mopen">(</span><span class="mord mathdefault">d</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">d</span><span class="mopen">[</span><span class="mord mathdefault">x</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">e</span><span class="mord mathdefault">d</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">e</span><span class="mclose">)</span></span></span></span><br>
每个点的<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>i</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">dis</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">i</span><span class="mord mathdefault">s</span></span></span></span>就代表了<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>t</mi><mi>a</mi></mrow><annotation encoding="application/x-tex">ta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault">t</span><span class="mord mathdefault">a</span></span></span></span>的最大值 如果一个点有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>v</mi><mi>a</mi><mi>l</mi><mo>[</mo><mi>x</mi><mo>]</mo><mo>&gt;</mo><mi>d</mi><mi>i</mi><mi>s</mi><mo>[</mo><mi>x</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">val[x]&gt;dis[x]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mopen">[</span><span class="mord mathdefault">x</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">i</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault">x</span><span class="mclose">]</span></span></span></span><br>
那么是不合法的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>i</mi><mi>s</mi><mo>&lt;</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">dis&lt;0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.73354em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">i</span><span class="mord mathdefault">s</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>也是不合法的<br>
最后输出<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>i</mi></mrow><annotation encoding="application/x-tex">di</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">i</span></span></span></span>s 就是每个数的最大值的构造方案<br>
当然也可以小的数向大的数连边 最后<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>t</mi><mi>o</mi><mi>p</mi><mi>o</mi></mrow><annotation encoding="application/x-tex">topo</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.80952em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">t</span><span class="mord mathdefault">o</span><span class="mord mathdefault">p</span><span class="mord mathdefault">o</span></span></span></span>出来的就是最小值的构造方案</p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
#define int long long 

const int N=500010;
int n,s,m,cnt,val[N];

struct Graph{
	bool v[N];
	int tot,head[N],suiv[N*10],edge[N*10],ver[N*10],ind[N],d[N];
	queue&lt;int&gt;q;
	#define lnk(x,y,z) e.add(x,y,z) 
	inline void add(int x,int y,int z){
		ver[++tot]=y,edge[tot]=z;
		suiv[tot]=head[x],head[x]=tot;ind[y]++;
	}
	
	inline void topo(){
		while(q.size())q.pop();
		for(int i=1;i&lt;=cnt;i++){
			if(!d[i])d[i]=1000000000;
			if(!ind[i])q.push(i);
		}
		while(q.size()){
			int x=q.front();
			q.pop();
			for(int i=head[x];i;i=suiv[i]){
				int y=ver[i],z=edge[i];
				d[y]=min(d[y],d[x]-z);
				if(~val[y] &amp;&amp; val[y]&gt;d[y])
					{puts(&quot;NIE&quot;);exit(0);}
				if(!--ind[y])q.push(y);
			}
		}
	}
	
}e;

struct SegmentTree{
	int id[N&lt;&lt;2];
	#define id(x) id[x]
	//op==0 means IndegreeTree
	inline void build(int p,int l,int r,bool op){  
		if(l==r){id(p)=l;return;}
		int mid=l+r&gt;&gt;1;
		build(p&lt;&lt;1,l,mid,op),build(p&lt;&lt;1|1,mid+1,r,op);
		id(p)=++cnt;
		(op?(lnk(id(p&lt;&lt;1),id(p),0),lnk(id(p&lt;&lt;1|1),id(p),0)):
			(lnk(id(p),id(p&lt;&lt;1),0),lnk(id(p),id(p&lt;&lt;1|1),0)));
	}
	
	inline void conct(int p,int l,int r,int L,int R,int nou,int w,bool op){
		if(L&lt;=l &amp;&amp; r&lt;=R){op?lnk(id(p),nou,w):lnk(nou,id(p),w);return;}
		int mid=l+r&gt;&gt;1;
		if(L&lt;=mid)conct(p&lt;&lt;1,l,mid,L,R,nou,w,op);
		if(R&gt;mid)conct(p&lt;&lt;1|1,mid+1,r,L,R,nou,w,op);
	}
	
}tIn,tOut;

signed main()
{
	memset(val,-1,sizeof(val));
	scanf(&quot;%lld%lld%lld&quot;,&amp;n,&amp;s,&amp;m);
	for(int i=1,x,y;i&lt;=s;i++)
		scanf(&quot;%lld%lld&quot;,&amp;x,&amp;y),val[x]=e.d[x]=y;
	cnt=n;
	tIn.build(1,1,n,0),tOut.build(1,1,n,1);
	for(int i=1,l,r,k;i&lt;=m;i++)
	{
		scanf(&quot;%lld%lld%lld&quot;,&amp;l,&amp;r,&amp;k);
		cnt++;
		int lst=l;
		for(int i=1,pos;i&lt;=k;i++)
		{
			scanf(&quot;%lld&quot;,&amp;pos);
			if(pos&gt;lst)tIn.conct(1,1,n,lst,pos-1,cnt,1,0);
			tOut.conct(1,1,n,pos,pos,cnt,0,1);
			lst=pos+1;
			if(i==k &amp;&amp; lst&lt;=r)
				tIn.conct(1,1,n,lst,r,cnt,1,0);
		}
	}
	e.topo();
	for(int i=1;i&lt;=cnt;i++)
		if(e.ind[i] || e.d[i]&lt;=0){puts(&quot;NIE&quot;);return 0;}
	puts(&quot;TAK&quot;);
	for(int i=1;i&lt;=n;i++)
		printf(&quot;%lld &quot;,e.d[i]);
	return 0;
} 
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[USACO08MAR LandAcquisition 斜率优化DP]]></title>
        <id>https://rainyclementine.github.io/post/usaco08mar-landacquisition-xie-lu-you-hua-dp</id>
        <link href="https://rainyclementine.github.io/post/usaco08mar-landacquisition-xie-lu-you-hua-dp">
        </link>
        <updated>2019-10-14T08:32:10.000Z</updated>
        <content type="html"><![CDATA[<p>给定<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>个矩形 可以将<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>t</mi><mi>a</mi></mrow><annotation encoding="application/x-tex">ta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault">t</span><span class="mord mathdefault">a</span></span></span></span>们不连续的分成若干组<br>
每组的代价是这组内的宽最大值乘长最大值<br>
求最小代价</p>
<p>用<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>r</mi></mrow><annotation encoding="application/x-tex">r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span></span></span></span>表示长 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi></mrow><annotation encoding="application/x-tex">c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">c</span></span></span></span>表示宽<br>
对于矩形<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi><mi>B</mi></mrow><annotation encoding="application/x-tex">AB</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span> 如果<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi><mi mathvariant="normal">.</mi><mi>r</mi><mo>&lt;</mo><mo>=</mo><mi>B</mi><mi mathvariant="normal">.</mi><mi>r</mi></mrow><annotation encoding="application/x-tex">A.r&lt;=B.r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72243em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">A</span><span class="mord">.</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mord">.</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span></span></span></span> <span class='katex-error' title='ParseError: KaTeX parse error: Expected &#039;EOF&#039;, got &#039;&amp;&#039; at position 1: &amp;̲&amp;'>&amp;&amp;</span> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi><mi mathvariant="normal">.</mi><mi>c</mi><mo>&lt;</mo><mo>=</mo><mi>B</mi><mi mathvariant="normal">.</mi><mi>c</mi></mrow><annotation encoding="application/x-tex">A.c&lt;=B.c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72243em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">A</span><span class="mord">.</span><span class="mord mathdefault">c</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mord">.</span><span class="mord mathdefault">c</span></span></span></span> 那么<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span></span></span></span>是无用的<br>
那么可以按r排序后用单调栈去重 只剩下有用的矩阵<br>
对于剩下的矩阵<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi><mi>B</mi><mi>C</mi></mrow><annotation encoding="application/x-tex">A B C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span></span></span></span> 如果有<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi><mi mathvariant="normal">.</mi><mi>r</mi><mo>&lt;</mo><mo>=</mo><mi>B</mi><mi mathvariant="normal">.</mi><mi>r</mi><mo>&lt;</mo><mo>=</mo><mi>C</mi><mi mathvariant="normal">.</mi><mi>r</mi></mrow><annotation encoding="application/x-tex">A.r&lt;=B.r&lt;=C.r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72243em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">A</span><span class="mord">.</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72243em;vertical-align:-0.0391em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mord">.</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mord">.</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span></span></span></span> 那么必然有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi><mi mathvariant="normal">.</mi><mi>c</mi><mo>&gt;</mo><mo>=</mo><mi>B</mi><mi mathvariant="normal">.</mi><mi>c</mi><mo>&gt;</mo><mo>=</mo><mi>C</mi><mi mathvariant="normal">.</mi><mi>r</mi></mrow><annotation encoding="application/x-tex">A.c&gt;=B.c&gt;=C.r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72243em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">A</span><span class="mord">.</span><span class="mord mathdefault">c</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72243em;vertical-align:-0.0391em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mord">.</span><span class="mord mathdefault">c</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mord">.</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span></span></span></span><br>
如果将<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi><mi>C</mi></mrow><annotation encoding="application/x-tex">AC</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span></span></span></span>分成一组 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span>单独一组 对答案的贡献是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>C</mi><mi mathvariant="normal">.</mi><mi>r</mi><mo>∗</mo><mi>A</mi><mi mathvariant="normal">.</mi><mi>c</mi><mo>+</mo><mi>B</mi><mi mathvariant="normal">.</mi><mi>r</mi><mo>∗</mo><mi>B</mi><mi mathvariant="normal">.</mi><mi>c</mi></mrow><annotation encoding="application/x-tex">C.r*A.c + B.r*B.c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mord">.</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">A</span><span class="mord">.</span><span class="mord mathdefault">c</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mord">.</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mord">.</span><span class="mord mathdefault">c</span></span></span></span><br>
如果<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi><mi>B</mi><mi>C</mi></mrow><annotation encoding="application/x-tex">ABC</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span></span></span></span>一组 对答案的贡献是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>C</mi><mi mathvariant="normal">.</mi><mi>r</mi><mo>∗</mo><mi>A</mi><mi mathvariant="normal">.</mi><mi>c</mi></mrow><annotation encoding="application/x-tex">C.r*A.c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mord">.</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span><span class="mord">.</span><span class="mord mathdefault">c</span></span></span></span> 显然更优<br>
于是这就是一个连续分组问题 可以<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>p</mi></mrow><annotation encoding="application/x-tex">dp</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span></span></span></span><br>
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>[</mo><mi>i</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">f[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span></span></span></span>表示分前i个的最小代价<br>
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>=</mo><mi>m</mi><mi>i</mi><mi>n</mi><mrow><mi>f</mi><mo>[</mo><mi>j</mi><mo>]</mo><mo>+</mo><mi>p</mi><mo>[</mo><mi>i</mi><mo>]</mo><mi mathvariant="normal">.</mi><mi>r</mi><mo>+</mo><mo>∗</mo><mi>p</mi><mo>[</mo><mi>j</mi><mo>+</mo><mn>1</mn><mo>]</mo><mi mathvariant="normal">.</mi><mi>c</mi></mrow></mrow><annotation encoding="application/x-tex">f[i]=min{f[j]+p[i].r+*p[j+1].c}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mord">.</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">∗</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mord">.</span><span class="mord mathdefault">c</span></span></span></span></span><br>
当决策<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span>比决策<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>更优时 有<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi><mo>[</mo><mi>i</mi><mo>]</mo><mi mathvariant="normal">.</mi><mi>r</mi><mo>&lt;</mo><mo>(</mo><mi>f</mi><mo>[</mo><mi>j</mi><mo>]</mo><mo>−</mo><mi>f</mi><mo>[</mo><mi>k</mi><mo>]</mo><mo>)</mo><mi mathvariant="normal">/</mi><mo>(</mo><mi>p</mi><mo>[</mo><mi>k</mi><mo>+</mo><mn>1</mn><mo>]</mo><mi mathvariant="normal">.</mi><mi>c</mi><mo>−</mo><mi>p</mi><mo>[</mo><mi>j</mi><mo>+</mo><mn>1</mn><mo>]</mo><mi mathvariant="normal">.</mi><mi>c</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">p[i].r&lt;(f[j]-f[k])/(p[k+1].c-p[j+1].c)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mord">.</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">]</span><span class="mclose">)</span><span class="mord">/</span><span class="mopen">(</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mord">.</span><span class="mord mathdefault">c</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mord">.</span><span class="mord mathdefault">c</span><span class="mclose">)</span></span></span></span></p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
#define int long long 

const int N=50010;
int n,cnt,f[N],q[N];
struct Node{
	int r,c;
	inline bool operator &lt;(const Node&amp; that)const{
		return r==that.r ? c&lt;that.c : r&lt;that.r;
	}
}a[N],p[N];

inline double slope(int x,int y){
	return (1.0*f[x]-f[y])/(1.0*p[y+1].c-p[x+1].c);
}

signed main()
{
	scanf(&quot;%lld&quot;,&amp;n);
	for(int i=1;i&lt;=n;i++)
		scanf(&quot;%lld%lld&quot;,&amp;a[i].r,&amp;a[i].c);
	sort(a+1,a+1+n);	
	for(int i=1;i&lt;=n;i++)
	{
		while(cnt &amp;&amp; a[i].c&gt;=p[cnt].c)cnt--;
		p[++cnt]=a[i];
	}
	int l=1,r=1;
	for(int i=1;i&lt;=cnt;i++)
	{
		while(l&lt;r &amp;&amp; slope(q[l],q[l+1])&lt;=1.0*p[i].r)l++;
		f[i]=f[q[l]]+p[i].r*p[q[l]+1].c;
		while(l&lt;r &amp;&amp; slope(i,q[r])&lt;slope(q[r],q[r-1]))r--;
		q[++r]=i;
	}
	printf(&quot;%lld\n&quot;,f[cnt]);
	return 0;
} 
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[网络流24题 餐巾计划问题 费用流 贪心]]></title>
        <id>https://rainyclementine.github.io/post/wang-luo-liu-24-ti-can-jin-ji-hua-wen-ti-fei-yong-liu-tan-xin</id>
        <link href="https://rainyclementine.github.io/post/wang-luo-liu-24-ti-can-jin-ji-hua-wen-ti-fei-yong-liu-tan-xin">
        </link>
        <updated>2019-10-12T09:24:13.000Z</updated>
        <content type="html"><![CDATA[<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>H</mi><mi>N</mi><mi>O</mi><mi>I</mi></mrow><annotation encoding="application/x-tex">HNOI</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.08125em;">H</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span></span></span></span>软件开发/餐巾计划问题<br>
每个开发人员每天需要一块消毒毛巾 这种消毒毛巾使用一天后<br>
必须再做消毒处理后才能使用 消毒方式有两种<br>
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span></span></span></span>种方式的消毒需要a天时间 B种方式的消毒需要<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span></span></span></span>天（<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>b</mi><mo>&gt;</mo><mi>a</mi></mrow><annotation encoding="application/x-tex">b&gt;a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.73354em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">b</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span></span></span></span>）<br>
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span></span></span></span>种消毒方式的费用为每块毛巾<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mi>A</mi></mrow><annotation encoding="application/x-tex">fA</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">A</span></span></span></span><br>
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span>种消毒方式的费用为每块毛巾<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mi>B</mi></mrow><annotation encoding="application/x-tex">fB</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span> 而买一块新毛巾的费用为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span></span></span></span><br>
新毛巾是已消毒的 当天可以使用 而且<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>&gt;</mo><mi>f</mi><mi>A</mi><mo>&gt;</mo><mi>f</mi><mi>B</mi></mrow><annotation encoding="application/x-tex">f&gt;fA&gt;fB</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">A</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span><br>
第<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span>天有<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi><mi>i</mi></mrow><annotation encoding="application/x-tex">ci</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault">i</span></span></span></span>个开发人员 求最小花费</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>H</mi><mi>N</mi><mi>O</mi><mi>I</mi></mrow><annotation encoding="application/x-tex">HNOI</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.08125em;">H</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span></span></span></span>软件开发同网络流<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>24</mn></mrow><annotation encoding="application/x-tex">24</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">4</span></span></span></span>题餐巾计划问题 就是要<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">a+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>天洗好<br>
而餐巾计划<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span></span></span></span>天洗好<br>
这两道题数据范围小 可以费用流求解<br>
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi><mo>−</mo><mo>&gt;</mo><mi>x</mi><mi>i</mi></mrow><annotation encoding="application/x-tex">S-&gt;xi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord">−</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">x</span><span class="mord mathdefault">i</span></span></span></span> 容量为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi><mi>i</mi></mrow><annotation encoding="application/x-tex">ci</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault">i</span></span></span></span>费用为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span><br>
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>y</mi><mi>i</mi><mo>−</mo><mo>&gt;</mo><mi>T</mi></mrow><annotation encoding="application/x-tex">yi-&gt;T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mord mathdefault">i</span><span class="mord">−</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span></span></span></span> 容量为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi><mi>i</mi></mrow><annotation encoding="application/x-tex">ci</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault">i</span></span></span></span>费用为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span><br>
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi><mo>−</mo><mo>&gt;</mo><mi>y</mi><mi>i</mi></mrow><annotation encoding="application/x-tex">S-&gt;yi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord">−</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mord mathdefault">i</span></span></span></span> 容量为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi><mi>i</mi><mi>i</mi><mi>n</mi><mi>f</mi></mrow><annotation encoding="application/x-tex">ci inf</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault">i</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span></span></span></span>也一样 费用为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span></span></span></span><br>
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mi>i</mi><mo>−</mo><mo>&gt;</mo><mi>x</mi><mi>i</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">xi-&gt;xi+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.74285em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">x</span><span class="mord mathdefault">i</span><span class="mord">−</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.74285em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">x</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 容量为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi><mi>n</mi><mi>f</mi></mrow><annotation encoding="application/x-tex">inf</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span></span></span></span>费用为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span><br>
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mi>i</mi><mo>−</mo><mo>&gt;</mo><mi>y</mi><mi>i</mi><mo>+</mo><mi>a</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">xi-&gt;yi+a+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.74285em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">x</span><span class="mord mathdefault">i</span><span class="mord">−</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 容量为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi><mi>n</mi><mi>f</mi></mrow><annotation encoding="application/x-tex">inf</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span></span></span></span>费用为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mi>a</mi></mrow><annotation encoding="application/x-tex">fa</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">a</span></span></span></span><br>
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mi>i</mi><mo>−</mo><mo>&gt;</mo><mi>y</mi><mi>i</mi><mo>+</mo><mi>b</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">xi-&gt;yi+b+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.74285em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">x</span><span class="mord mathdefault">i</span><span class="mord">−</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">b</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 容量为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi><mi>n</mi><mi>f</mi></mrow><annotation encoding="application/x-tex">inf</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span></span></span></span>费用为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mi>b</mi></mrow><annotation encoding="application/x-tex">fb</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">b</span></span></span></span><br>
将<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mi>i</mi></mrow><annotation encoding="application/x-tex">xi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">x</span><span class="mord mathdefault">i</span></span></span></span>看作脏毛巾 将<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>y</mi><mi>i</mi></mrow><annotation encoding="application/x-tex">yi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mord mathdefault">i</span></span></span></span>看作干净的毛巾 每天买毛巾的价格相同<br>
所以一定是洗完或买完毛巾就立刻使用 所以<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>y</mi><mi>i</mi></mrow><annotation encoding="application/x-tex">yi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mord mathdefault">i</span></span></span></span>直接向<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault">t</span></span></span></span>连边<br>
每天能够得到<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi><mi>i</mi></mrow><annotation encoding="application/x-tex">ci</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault">i</span></span></span></span>条脏毛巾 这些脏毛巾不一定立刻送洗<br>
所以<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mi>i</mi></mrow><annotation encoding="application/x-tex">xi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">x</span><span class="mord mathdefault">i</span></span></span></span>想<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mi>i</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">xi+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.74285em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">x</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>连边 表示留到下一天</p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;

const int N=2010;
const int M=8010;
const int inf=0x7fffffff;
int n,tot=1,st,ed,head[N],flow[N],d[N],pre[N],idx[N];
int a,b,f,fa,fb,c[N];
bool v[N];
struct Edge{
	int ver,suiv,edge,cos;
}e[M&lt;&lt;1];

inline void lnk(int x,int y,int z,int w)
{
	e[++tot].ver=y;
	e[tot].edge=z;
	e[tot].cos=w;
	e[tot].suiv=head[x];
	head[x]=tot;
}

inline bool spfa()
{
	queue&lt;int&gt;q;
	memset(flow,0x3f,sizeof(flow));
	memset(d,0x3f,sizeof(d));
	memset(v,0,sizeof(v));
	d[st]=0;
	q.push(st);
	pre[ed]=-1;
	while(q.size())
	{
		int x=q.front();
		q.pop();
		v[x]=0;
		for(int i=head[x];i;i=e[i].suiv)
		{
			int y=e[i].ver,w=e[i].cos,z=e[i].edge;
			if(!z || d[y]&lt;=d[x]+w)continue;
			d[y]=d[x]+w;
			pre[y]=x;
			idx[y]=i;
			flow[y]=min(flow[x],z);
			if(!v[y])q.push(y),v[y]=1;
		}
	}
	return ~pre[ed];
}

inline int mcmf()
{
	int res=0;
	while(spfa())
	{
		int pos=ed;
		res+=d[ed]*flow[ed];
		while(pos!=st)
		{
			e[idx[pos]].edge-=flow[ed];
			e[idx[pos]^1].edge+=flow[ed];
			pos=pre[pos];
		}
	}
	return res;
}

int main()
{
	scanf(&quot;%d%d%d%d%d%d&quot;,&amp;n,&amp;a,&amp;b,&amp;f,&amp;fa,&amp;fb);
	st=0,ed=n&lt;&lt;1|1;
	for(int i=1;i&lt;=n;i++)
		scanf(&quot;%d&quot;,&amp;c[i]);
	for(int i=1;i&lt;=n;i++)
		lnk(st,i,c[i],0),lnk(i,st,0,0),
		lnk(st,i+n,inf,f),lnk(i+n,st,0,-f),
		lnk(i+n,ed,c[i],0),lnk(ed,i+n,0,0);
	for(int i=1;i+a+1&lt;=n;i++)
		lnk(i,i+a+1+n,inf,fa),lnk(i+a+1+n,i,0,-fa);
	for(int i=1;i+b+1&lt;=n;i++)
		lnk(i,i+b+1+n,inf,fb),lnk(i+b+1+n,i,0,-fb);
	for(int i=1;i&lt;n;i++)
		lnk(i,i+1,inf,0),lnk(i+1,i,0,0);
	printf(&quot;%d\n&quot;,mcmf());
	return 0;
}
</code></pre>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi><mi>J</mi><mi>W</mi><mi>C</mi><mn>2018</mn></mrow><annotation encoding="application/x-tex">BJWC2018</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mord mathdefault" style="margin-right:0.09618em;">J</span><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mord">2</span><span class="mord">0</span><span class="mord">1</span><span class="mord">8</span></span></span></span> 餐巾计划问题 / <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>U</mi><mi>S</mi><mi>A</mi><mi>C</mi><mi>O</mi><mn>08</mn><mi>N</mi><mi>O</mi><mi>V</mi><mi>T</mi><mi>o</mi><mi>y</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">USACO08NOV Toys</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">U</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault">A</span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mord">0</span><span class="mord">8</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mord mathdefault">s</span></span></span></span><br>
题意一样 但是数据加强 考虑贪心<br>
以下内容大量借鉴 radish布団 大佬<br>
https://www.luogu.org/blog/radish/solution-p4480</p>
<p>我们假设在这n天内一共购买了<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span>块新餐巾 而最优解一共购买了<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>m</mi><mi>a</mi></msub><mi>n</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">m_ans</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">a</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">n</span><span class="mord mathdefault">s</span></span></span></span><br>
若<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi><mo>=</mo><msub><mi>m</mi><mi>a</mi></msub><mi>n</mi><mi>s</mi><mo>+</mo><mi>k</mi></mrow><annotation encoding="application/x-tex">m=m_ans+k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.73333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">a</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">n</span><span class="mord mathdefault">s</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>由于购买新餐巾必然比洗旧餐巾贵 因此多买必定不优<br>
若<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi><mo>=</mo><msub><mi>m</mi><mi>a</mi></msub><mi>n</mi><mi>s</mi><mo>−</mo><mi>k</mi></mrow><annotation encoding="application/x-tex">m=m_ans-k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.73333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">a</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">n</span><span class="mord mathdefault">s</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>那么在网络流的图上表示买新餐巾的边就少流了一次<br>
由于在网络流中我们寻找的是最短路 那么少流一条最短路中的边也就说明走了一条较长路<br>
因此少买必定不优 综上 总花费关于新餐巾购买数的函数<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>(</mo><mi>x</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">f(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span></span> 为单峰函数 三分解决</p>
<p>通过分析网络流解法的建图方式可以发现 每天的干净餐巾来源有4个<br>
1在前几天买了但还没用完的干净餐巾<br>
2在今天买的干净餐巾<br>
3在timfst天前送去慢洗部的脏餐巾<br>
4在timslo天前送去快洗部的脏餐巾</p>
<p>可以依据以上四条进行贪心<br>
1若还有新餐巾没用完 则先用新餐巾<br>
2新餐巾用完后 优先用慢洗部送来的餐巾 且优先用较晚送来的餐巾<br>
3慢洗部送来的餐巾用完后 用快洗部送来的餐巾 且优先用较晚送来的餐巾<br>
4若快洗部送来的餐巾用完后仍不满足今日所需 则说明此情况无解</p>
<p>关于第二条 有可能我们一些餐巾正在快洗部 一些餐巾在慢洗部<br>
先用慢洗部的 给了快洗部的餐巾可能到慢洗部洗的机会</p>
<p>三分卖多少条餐巾 在第一天就把它们全买了<br>
我们维护三个队列<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mi>o</mi><mi>u</mi><mi>f</mi><mi>s</mi><mi>t</mi><mi>f</mi><mi>l</mi><mi>o</mi></mrow><annotation encoding="application/x-tex">nou fst flo</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">o</span><span class="mord mathdefault">u</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span></span></span></span><br>
队列每个元素维护这一组餐巾上一次被用完的时间<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mi>i</mi><mi>r</mi><mi>s</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">first</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span></span></span></span>数量<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mi>e</mi><mi>c</mi><mi>o</mi><mi>n</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">second</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">e</span><span class="mord mathdefault">c</span><span class="mord mathdefault">o</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span></span></span></span><br>
每天一过 将当天用过的餐巾加到<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mi>o</mi><mi>u</mi></mrow><annotation encoding="application/x-tex">nou</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">o</span><span class="mord mathdefault">u</span></span></span></span>队列中 表示正在慢洗<br>
每天一开始 检查<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mi>o</mi><mi>u</mi></mrow><annotation encoding="application/x-tex">nou</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">o</span><span class="mord mathdefault">u</span></span></span></span> 检查最早加入的元素是否被快洗完了<br>
完了就加入<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mi>s</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">fst</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span></span></span></span> 表示完成快洗 正在慢洗<br>
对于<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mi>s</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">fst</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span></span></span></span>队列同理<br>
对于每天需要的餐巾 先用买过的 在取完成慢洗的较晚的<br>
再取完成快洗较晚的</p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
#define fir first
#define sec second

const int N=200010;
typedef pair&lt;int,int&gt; pii;
int n,r[N],sum,prislo,prifst,prinou,timslo,timfst;
deque&lt;pii&gt;slo,fst,nou;

inline int cal(int buy)
{
	int res=prinou*buy;
	slo.clear(),fst.clear(),nou.clear();
	for(int i=1;i&lt;=n;i++)
	{
		while(nou.size() &amp;&amp; nou.front().fir&lt;=i-timfst)
			fst.push_back(nou.front()),nou.pop_front();
		while(fst.size() &amp;&amp; fst.front().fir&lt;=i-timslo)
			slo.push_back(fst.front()),fst.pop_front();
		int ned=r[i],mini=min(ned,buy);
		buy-=mini,ned-=mini;
		while(ned &amp;&amp; slo.size())
		{
			int tem=min(ned,slo.back().sec);
			res+=tem*prislo;
			ned-=tem;
			if(tem==slo.back().sec)slo.pop_back();
			else slo.back().sec-=tem;
		}
		while(ned &amp;&amp; fst.size())
		{
			int tem=min(ned,fst.back().sec);
			res+=tem*prifst;
			ned-=tem;
			if(tem==fst.back().sec)fst.pop_back();
			else fst.back().sec-=tem;
		}
		if(ned)return 0x7fffffff;
		nou.push_back(make_pair(i,r[i]));
	}
	return res;
}

int main()
{
	scanf(&quot;%d%d%d%d%d%d&quot;,&amp;n,&amp;timfst,&amp;timslo,&amp;prifst,&amp;prislo,&amp;prinou);
	if(timfst&gt;timslo)swap(timfst,timslo),swap(prifst,prislo);
	if(prislo&gt;prifst)prislo=prifst,timslo=timfst;
	for(int i=1;i&lt;=n;i++)
		scanf(&quot;%d&quot;,&amp;r[i]),sum+=r[i];
	int l=0,r=sum;
	while(r-l&gt;2)
	{
		int midl=(l*2+r)/3,midr=(l+r*2+2)/3;
		int pril=cal(midl),prir=cal(midr);
		pril&gt;=prir ? l=midl : r=midr;
	}
	int ans=0x7fffffff;
	for(int i=l;i&lt;=r;i++)
		ans=min(ans,cal(i));
	printf(&quot;%d\n&quot;,ans);
	return 0;
}
</code></pre>
]]></content>
    </entry>
</feed>