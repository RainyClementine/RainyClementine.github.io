<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://rainyclementine.github.io</id>
    <title>Siilhouette</title>
    <updated>2019-09-24T09:37:02.371Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://rainyclementine.github.io"/>
    <link rel="self" href="https://rainyclementine.github.io/atom.xml"/>
    <subtitle>Rearrange the stars</subtitle>
    <logo>https://rainyclementine.github.io/images/avatar.png</logo>
    <icon>https://rainyclementine.github.io/favicon.ico</icon>
    <rights>All rights reserved 2019, Siilhouette</rights>
    <entry>
        <title type="html"><![CDATA[POJ3585 AccumulationDegree 换根DP]]></title>
        <id>https://rainyclementine.github.io/post/poj3585-accumulationdegree-huan-gen-dp</id>
        <link href="https://rainyclementine.github.io/post/poj3585-accumulationdegree-huan-gen-dp">
        </link>
        <updated>2019-09-24T09:34:51.000Z</updated>
        <content type="html"><![CDATA[<p>给定一棵树 每条边有流量限制w(x,y) 每个叶子都是汇点<br>
求以哪个店为源点时 流量最大</p>
<p>先求出以1为根时的每个点的流量d[i]<br>
d[x]=sigma{min(d[y],w(x,y))}<br>
当y是叶子时 d[x]=w(x,y)<br>
f[x]表示以x为根时的流量<br>
f[1]=d[1]<br>
f[y]=d[y]+min(f[x]-min(d[y],z),z)</p>
<p>f[x]-min(d[y],z)是除了y子树 其他点到x的流量<br>
当x是叶子时<br>
f[y]=d[y]+w(x,y)</p>
<pre><code>#include&lt;algorithm&gt;
#include&lt;cstring&gt;
#include&lt;cstdio&gt;
using namespace std;

const int N=300010;
int n,m,tot,head[N],ind[N],d[N],f[N];
struct Edge{
	int ver,suiv,edge;
}e[N&lt;&lt;1];

inline void lnk(int x,int y,int z)
{
	e[++tot].ver=y;
	e[tot].edge=z;
	e[tot].suiv=head[x];
	head[x]=tot;
}

inline void dfs1(int x,int fa)
{
	for(int i=head[x];i;i=e[i].suiv)
	{
		int y=e[i].ver,z=e[i].edge;
		if(y==fa)continue;
		dfs1(y,x);
		d[x]+=min(d[y],z);
		if(ind[y]==1)d[x]+=z;
	}
}

inline void dfs2(int x,int fa)
{
	if(x==1)f[x]=d[x];
	for(int i=head[x];i;i=e[i].suiv)
	{
		int y=e[i].ver,z=e[i].edge;
		if(y==fa)continue;
		if(ind[x]==1)f[y]=d[y]+z;
		else f[y]=d[y]+min(f[x]-min(d[y],z),z);
		dfs2(y,x);
	}
}

int main()
{
	int T;
	scanf(&quot;%d&quot;,&amp;T);
	while(T--)
	{
		tot=0;
		memset(f,0,sizeof(f));
		memset(d,0,sizeof(d));
		memset(ind,0,sizeof(ind));
		memset(head,0,sizeof(head));
		scanf(&quot;%d&quot;,&amp;n);
		for(int i=1,x,y,z;i&lt;n;i++)
			scanf(&quot;%d%d%d&quot;,&amp;x,&amp;y,&amp;z),
			lnk(x,y,z),lnk(y,x,z),ind[x]++,ind[y]++;
		dfs1(1,0);
		dfs2(1,0);
		int ans=0;
		for(int i=1;i&lt;=n;i++)
			ans=max(ans,f[i]);
		printf(&quot;%d\n&quot;,ans);
	}
	return 0;
} 
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[POI2014 Hotels 长链剖分优化树形DP]]></title>
        <id>https://rainyclementine.github.io/post/poi2014-hotels-chang-lian-pou-fen-you-hua-shu-xing-dp</id>
        <link href="https://rainyclementine.github.io/post/poi2014-hotels-chang-lian-pou-fen-you-hua-shu-xing-dp">
        </link>
        <updated>2019-09-24T06:57:19.000Z</updated>
        <content type="html"><![CDATA[<p>给定一棵树 每条边的长度相同 任意两个节点可以相互到达<br>
选3个点 两两距离相等 有多少种方案</p>
<p>f[x][i]表示x子树中距离x为i距离的点数<br>
g[x][i]表示x子树中到lca距离都是d lca到x距离是d-i的点对数量<br>
ans+=f[x][j-1]*g[y][j]<br>
ans+=g[x][j+1]*f[y][j]<br>
g[x][j+1]+=f[x][j+1]*f[y][j]<br>
g[x][j-1]+=g[y][j]<br>
f[x][j+1]+=f[y][j]<br>
*f[i] *g[i]共同使用tem内存池 所以tem要开两倍<br>
内存池id指针移动时要移动两倍距离</p>
<pre><code>#include&lt;bits/stdc++.h&gt;
using namespace std;

const int N=100010;
typedef long long ll;
int n,tot,head[N],d[N],son[N];
ll tem[N&lt;&lt;1],*f[N],*g[N],*id=tem,ans;
struct Edge{
	int ver,suiv;
}e[N&lt;&lt;1];

inline void lnk(int x,int y)
{
	e[++tot].ver=y;
	e[tot].suiv=head[x];
	head[x]=tot;
}

inline void dfs1(int x,int fa)
{
	for(int i=head[x];i;i=e[i].suiv)
	{
		int y=e[i].ver;
		if(y==fa)continue;
		dfs1(y,x);
		if(d[y]&gt;d[son[x]])son[x]=y;
	}
	d[x]=d[son[x]]+1;
}

inline void dfs2(int x,int fa)
{
	if(son[x])
		f[son[x]]=f[x]+1,g[son[x]]=g[x]-1,dfs2(son[x],x);
	f[x][0]=1,ans+=g[x][0];
	for(int i=head[x];i;i=e[i].suiv)
	{
		int y=e[i].ver;
		if(y==fa || y==son[x])continue;
		f[y]=id,id+=d[y]&lt;&lt;1;
		g[y]=id,id+=d[y]&lt;&lt;1;
		dfs2(y,x);
		for(int j=0;j&lt;d[y];j++)
		{
			if(j)ans+=f[x][j-1]*g[y][j];
			ans+=g[x][j+1]*f[y][j];
		}
		for(int j=0;j&lt;d[y];j++)
		{			
			g[x][j+1]+=f[x][j+1]*f[y][j];
			if(j)g[x][j-1]+=g[y][j];
			f[x][j+1]+=f[y][j];
		}
	}
}

int main()
{
	scanf(&quot;%d&quot;,&amp;n);
	for(int i=1,x,y;i&lt;n;i++)
		scanf(&quot;%d%d&quot;,&amp;x,&amp;y),
		lnk(x,y),lnk(y,x);
	dfs1(1,0);
	f[1]=id,id+=d[1]&lt;&lt;1;
	g[1]=id,id+=d[1]&lt;&lt;1;
	dfs2(1,0);
	printf(&quot;%lld\n&quot;,ans);
	return 0;
} 
</code></pre>
]]></content>
    </entry>
</feed>